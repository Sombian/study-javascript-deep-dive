# 04장_변수

## 변수란?

> 하나의 값을 저장하기 위해 확보한 메모리 공간 자체
> 

**OR**

> 그 메모리 공간을 식별하기 위해 붙인 이름
> 

→ **값의 위치를 가리키는 상징적인 이름**

### 변수에 여러 개의 값을 저장하는 방법

```jsx
// 1. 하나의 값을 저장하기 위한 수단
var userId = 1;
var userName = 'Bae';

// 2. 객체나 배열 같은 자료구조를 사용 -> 여러 개의 값을 하나로 그룹화 가능
var user = {id : 1, name: 'Bae'};
```

**변수 이름**(위의 `user`): 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름

**변수 값**(위의 `id ,name` ): 변수에 저장된 값

**할당**: 변수에 값을 저장하는 것

**참조**: 변수에 저장된 값을 읽어 들이는 것

## 식별자

> 어떤 값을 **구별해서 식별**할 ****수 있는 **고유한 이름**
> 

→ **값이 아닌 메모리 주소를 기억하고 있다**. 메모리 주소에 붙인 이름!

변수, 함수, 클래스 등의 이름은 전부 다 식별자이다.

## 변수 선언

변수를 생성한다는 것.

변수를 사용하기 위해선 반드시 선언이 필요하다.

선언하지 않은 식별자에 접근하면 `ReferenceError`(참조 에러)가 발생한다.

`var`

- 선언과 초기화가 동시에 진행된다.
- 재선언, 재할당이 가능하다.

`let` (ES6)

- 선언만 이루어진다.
- 재할당이 가능한다.

`const` (상수, ES6)

- 선언만 이루어진다.
- 전부 불가능하다.

```jsx
var score; //변수 선언문

// 아무것도 할당하지 않을 시 undefined 값이 암묵적으로 할당된다.

/*
1. 선언 단계 : 변수 이름을 등록
2. 초기화 단계 : 값을 저장하기 위해 메모리 공간을 확보, undefined 할당해 초기화
								이전에 다른 애플리케이션이 사용했던 값(쓰레기 값)이 남아 있을 수 있다.
*/
```

### var은 왜 자주 사용하지 않나요? (ES5 → ES6)

1. 블록 레벨 스코프를 지원하지 않는다.
2. 함수 레벨 스코프를 지원한다.

→ **의도치 않게 전역변수가 선언되는 일**이 있으므로 심각한 부작용이 발생할 수 있다!

## 변수 선언의 실행 시점

```jsx
console.log(score); //undefined

var score; //변수 선언
```

> 변수 선언은 **런타임이 아닌 그 이전 단계에서 실행**되므로, 참조 에러가 발생하지 않았다!
> 

## 호이스팅

> **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징**
> 

→ 모든 식별자는 호이스팅된다.

## 할당

```jsx
var score = 80; // 변수 선언, 값의 할당
```

> 변수 선언: 런타임 이전 단계에서 실행
값의 할당: 런타임에서 실행
> 

```jsx
console.log(score); //undefined

var score = 80;

console.log(score); //80
```

## 재할당

이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것

```jsx
var score = 80;
score = 90; //재할당
```

## 식별자 네이밍 규칙

1. 특수문자를 제외한 `문자`, `숫자`, `_` , `$`를 포함할 수 있다.
2. 특수문자를 제외한 `문자`, `_` , `$`로 시작해야 한다.
3. 예약어는 사용할 수 없다(`await`, `if`, `let`…)

💡**네이밍 컨벤션 종류**

```jsx
var firstName; //카멜케이스
var first_name; //스네이크 케이스
var FirstName; //파스칼 케이스
var strFirstName; //헝가리언 케이스 (type + identifier)
```

**카멜 케이스**: 변수, 함수의 이름

**파스칼 케이스**: 생성자 함수, 클래스의 이름




# 05장_표현식과 문

## 값

> 식(표현식)이 **평가되어 생성된 결과**
> 

```jsx
//sum 변수에 할당되는 것은 10+20의 값인 30이다!
var sum = 10 + 20;
```

## 리터럴

> 사람이 이해할 수 있는 **문자 또는 약속된 기호**를 사용해 값을 생성하는 표기법
> 

→ `3`, `‘hello’`, `null`, `function(){}` …

## 표현식

> **값으로 평가**될 수 있는 문.
> 

→ 표현식이 평가되면 **새로운 값을 생성**하거나, **기존 값을 참조**한다.

```jsx
var score = 50 + 50;
score; //

// 리터럴 표현식
10, 'hello'

// 식별자 표현식(이미 선언했다고 가정)
sum, arr[1]...

// 연산자 표현식
50+50, sum!==10...

// 함수, 메서드 호출 표현식(이미 선언)
square(), person.getName()...
```

## 문

> **프로그램을 구성**하는 **기본 단위이자 최소 실행 단위**
> 

→ 변수 선언문, 할당문, 함수 선언문…이 있다. 여러 토큰으로 구성된다.

**💡토큰이란?**

문법적인 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소(`var`, `=`, `+`…)

## 표현식인 문, 표현식이 아닌 문

> 변수에 할당해보면 구별할 수 있다.
> 

```jsx
// 변수 선언문의 경우 값이 평가되지 않으므로 표현식이 아니다.
var score;

// 1, 2, 1+2, x=1+2 모두 표현식이다.
x = 1+2;

var score = var x; //표현식이 아니다.
```




# 06장_데이터 타입

## 데이터 타입

> **값의 종류**이다. ES6의 경우 7개의 데이터 타입을 제공한다.
**원시 타입**, **객체 타입**으로 분류가 가능하다.
> 


## 숫자

정수, 소수 등으로 나누지 않고 하나의 숫자 타입만 존재한다.

```jsx
var integer = 10; //정수
var double = 10.12 //실수;
var negative = -20 //음수;

// 모두 숫자 타입으로 처리한다.

var binary = 0b01000001; //2진수
var octal = 0o101; //8진수
var hex = 0x41; //16진수

console.log(binary); //65
console.log(octal); //65
console.log(hex); //65
console.log(binary === octal); //true
console.log(octal === hex); //true
```

`Infinity(양의 무한대)`, `-Infinity(음의 무한대)`, `NaN(산술 연산 불가)`을 표현할 수 있다.

## 문자열

텍스트 데이터를 나타내는 데 사요한다.

```jsx
var string;
string = '문자열'; // ''
string = "문자열"; // ""
string = `문자열`; // ``(백틱, ES6)
```

자바스크립트의 문자열은 원시 타입이므로, 변경 불가능한 값이다.

💡**템플릿 리터럴**

멀티라인 문자열, 표현식 삽입, 태그드 탬플릿 등의 기능을 제공한다. 
런타임에 일반 문자열로 변환되어 처리된다.

```jsx
// 멀티라인 문자열
var ex1 = 'hi
hello';

console.log(ex1) 
/* hi
	 hello */
	 
// 표현식 삽입
var first = 'Bae';
var last = 'Jun';
console.log('hi, ${first}${last}.'); //hi, Bae jun.
```

## 불리언

```jsx
var foo = true;
console.log(foo); //true

foo = false;
console.log(foo); //false
```

## undefined(정의되지 않은)

> 변수를 선언한 이후 값을 할당하지 않은 변수를 참조 시에 반환된다.
> 

→ 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값. 유일한 값이다.

```jsx
var foo;
console.log(foo); //undefined
```

## null

> 변수에 값이 없는 걸 **의도적으로 명시**하고 싶을 때 사용한다.
> 

null타입의 값은, null이 유일하다. 
함수가 유효한 값을 반환할 수 없는 경우에도 명시적으로 반환한다.

```jsx
var element = document.querySelector('.ex1');
console.log(element); //만약 ex1 클래스가 없을 시 null을 반환한다.
```

## 심벌 타입(ES6)

> 변경 불가능한 원시 타입의 값. 유일무이한 값이다.
> 

```jsx
var key = Symbol('key');
console.log(typeof key); //symbol
```

## 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
- 값을 참조할 때 한번에 읽어 들여야 할 **메모리 공간의 크기**를 정하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할 지 결정하기 위해

## 동적 타이핑

> 자바스크립트의 변수는 **선언이 아닌 할당**에 의해 타입이 **결정(추론)**된다.
재할당에 의해 변수의 타입은 언제든지 **동적**으로 변할 수 있다.
> 

→ 자바스크립트는 동적 언어니까! 정적 언어는 C, Java 등이 있다.

## 변수를 사용할 때 주의사항

- 필요한 경우에만 재한적으로 사용한다.
- 유효 범위(스코프)는 최대한 좁게 만들어 부작용을 억제하기.
- 전역 변수는 최대한 사용하지 않도록 한다.
- 변수보다는 상수를 사용하여 값의 변경을 억제한다.
- 변수 이름은 목적이나 의미를 파악할 수 있도록 네이밍한다.




# 07장_연산자

## 연산자와 피연산자

> **연산자**: 하나 이상의 표현식을 대상으로 산술, 할당 연산 등을 수행해 하나의 값을 만드는 것.
**피연산자**: 이러한 연산의 대상. 값으로 평가될 수 있는 표현식이어야 한다.
> 

## 산술 연산자

> 피연산자를 대상으로 수학적 계산을 수행해, 새로운 값을 만든다.
산술 연산이 불가능한 경우, `NaN`을 반환한다.
> 

### 이항 산술 연산자

2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

```jsx
5+2;
5-2;
5*2;
```

### 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

```jsx
var x = 1;

x++; // x = x + 1;
x--; // x = x - 1;

var ex1 = '1';
console.log(+ex1); //1. 문자열을 숫자로 타입 변환한다. 불리언 또한 가능하다.
var ex2 = 'hi';
console.log(+ex2); //NaN. 타입 변환이 불가능하다.
```

💡**증가/감소 연산자의 위치**

- 피연산자 **앞에** 위치한 경우 **먼저 값을 증가/감소** 시킨 후 다른 연산을 수행
- 피연산자 **뒤에** 위치한 경우 **다른 연산을 수행** 후 값을 증가/감소

```jsx
var x = 5, result;

result = x++;
console.log(result, x); // 5, 6

result = ++x; //x는 현재 6
console.log(result, x) // 7, 7
```

### 문자열 연결 연산자

`+` 연산자는 피연산자 중 하나 이상이 문자열일 경우, 문자열 연결 연산자로 동작한다.

```jsx
'1' + 2; // '12'
1 + '2'; // '12
```

## 할당 연산자

> 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
> 

```jsx
var x = 10;

x += 5; // x = x + 5;
console.log(x); //15

x -= 5; // x = x - 5;
console.log(x); //10

x *= 5; // x = x * 5; 50
x /= 5; // x = x / 5; 10
x %= 5; // x = x % 5; 0
```

## 비교 연산자

> 좌항과 우항의 피연산자를 비교한 다음, 그 결과를 불리언 값으로 반환한다.
> 

→ `if`문, `for`문과 같은 제어문의 조건식에서 자주 사용한다.

### 동등/일치 비교 연산자

동등 비교의 경우, 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.

일치 비교의 경우, 타입도 같고 값도 같아야 true를 반환한다.

```jsx
//동등 비교는 결과를 예측하기 어렵다. 자주 사용하지 말 것.
5 == '5'; //true

//일치 비교는 결과가 확실하다.
5 === '5'; //false

//NaN은 자신이 일치하지 않는다.
NaN === NaN; //false
```

### 대소 관계 비교 연산자

```jsx
5 > 5; //false
5 >= 5; //true
```

## 삼항 조건 연산자

> 조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
> 

→ 값으로 평가할 수 있는 표현식인 문. 수행문이 하나라면 삼항 연산자가 가독성이 좋다.

```jsx
var x = 2;

var result = x & 2 ? '홀수' : '짝수'; //2%2=0. 0은 false로 암묵적 타입 변환된다.
console.log(result); //짝수
```

## 논리 연산자

> `||` , `&&`, `!` 가 있다.
> 

```jsx
true || true; // true
true || false; // true
false || true; // true
false || false; // false

true && true; //true
true && false; //false
false && false; //false
false && false; //false

!true; //false
!false; //true

//드 모르간의 법칙
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```

## typef 연산자

> 피연산자의 데이터 타입을 문자열로 반환한다.
> 

```jsx
typeof '' // string
...
typeof null // object
```

💡**null값이 타입인지 확인할 때**

```jsx
// ===
var foo = null;
typeof foo === null; //false
foo === null; // true
```

💡**선언하지 않은 식별자**를 연산할 때

```jsx
typeof ex1; //undefined
```

## 지수 연산자

```jsx
2 ** 2 // 4
2 ** 2.5 // 5.65...
2 ** -2 // 0.25

//과거에는 Math.pow를 사용했다.
```

## 연산자의 부수 효과

> `=`, `++`/`--` , `delete` 의 경우 부수 효과가 있다.
> 

```jsx
var x;

x=1; //변수 값이 변하는 부수 효과

x++; //피연산자의 값을 변경하는 부수 효과

var ex1 = { a: 1};
delete ex1.a; //객체의 프로퍼티를 삭제하는 부수 효과
```