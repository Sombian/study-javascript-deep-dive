# 자료형
(Data Type)

자료형은, 다음과 같은 문제들을 해결하기 위해 등장했다.

- 이진값의 해석 방식을 결정하기 위해
- 이진값을 저장할 메모리 공간의 크기를 결정하기 위해
- 이진값을 참조할 메모리 공간의 크기를 결정하기 위해

## 정적 타입
(Static/Strong Type)

정적 타입 언어는, 변수의 자료형을 변경할 수 없으며, 컴파일 시점에서 자료형 확인(Type Checking)을 수행한다. 만약 자료형 확인을 통과하지 못하면 오류를 발생시키고 프로그램의 실행을 막는다. 이를 통해 자료형의 일관성을 강제함으로서 더욱 안정적으로 런타임 오류를 줄인다.

## 동적 타입
(Dynamic/Weak Type)

동적 타입 언어는, 변수의 자료형을 변경할 수 있다. 때문에 런타임에 변화하는 변수 값을 추적하기 어렵다는 단점이 존재한다. 더욱이 JavaScript은(는) 암묵적으로 형변환이 일어나기에 유연성이 뛰어나지만, 동시에 신뢰성이 떨어진다.

## 원시형
(Primitive Type)

원시형은, 자료형의 분류이다.

### 숫자

숫자는, 정수와 소수 등의 구분 없이 모두 배정밀도 64bit 부동소수점 방식을 사용한다.

[특수값]
- `NaN`
- `+Infinity`
- `-Inifity`

[보기 1]
```js
console.log(1 === 1.0); // true
```
### 문자열

문자열은, UTF-16 의 집합이다.

[보기 1]
```js
`hello`; // 백틱(Backtick)
```

[보기 2]
```js
'hello'; // 홑 따옴표(Single Quotation)
```

[보기 3]
```js
"hello"; // 쌍 따옴표(Double Quotation)
```

#### 템플레이트
(Template)

템플레이트는, ES6 부터 도입된 문자열의 기능으로, 편리한 기능들을 지원한다.

[보기 1]
```js
`lorem ipsum`;
```

##### 멀티라인
(Multi-Line)

템플레이트에서는, 이스케이프(`\`)를 사용하지 않아도 줄바꿈(개행)이 가능하며, 모든 공백도 그대로 적용된다.

[보기 1]
```js
`Roses are red
  Violets are blue,
Sugar is sweet
  And so are you.`;
```

##### 표현식 삽입
(Expression Interpolation)

템플레이트에서는, 문자열 연산자(`+`)를 사용하지 않아도 문자열을 삽입할 수 있다. 이때, 표현식의 결과가 문자열이 아니여도 자동으로 형변환(Type Conversion)이 일어난다.

[보기 1]
```js
var world = "world";

`hello ${world}`;
```

[보기 2]
```js
`10 + 20 = ${10 + 20}`;
```

### 논리형
(Boolean)

논리형은, `true`, `false` 두가지의 값만 존재하며, 조건문의 분기를 제어하기 위해 주로 사용된다.

[보기 1]
```js
true;
false;
```

### null

변수에 값이 없다는 것을 표현하기 위한 값이다.

### undefined

변수의 쓰레기 값을 제거하기 위해 사용되는 값이다.

### 심볼형
(Symbol)

심볼형은, ES6 부터 도입된 타입으로, 중복 불가능한 유일무이한 값을 가진다.

[보기 1]
```js
console.log(Symbol("foo") === Symbol("foo")); // false
```

[보기 2]
```js
console.log(Symbol.for("foo") === Symbol.for("foo")); // true
```

## 참조형
(Reference Type)

참조형은, 자료형의 분류이다.

### 객체
(Object)

객체는, 배열, 클래스 등을 포함한다.

[보기 1]
```js
const object = {
	snake_case: null, camelCase: null, PascalCase: null, "kebab-case": null,
};
```

#### 점표기법

[보기 1]
```js
object.snake_case;
object.camelCase;
object.PascalCase;
object.kebab-case; // TypeError
```

#### 괄호표기법

[보기 1]
```js
object["snake_case"];
object["camelCase"];
object["PascalCase"];
object["kebab-case"];
```

## Deep-Copy

값을 대입연산자를 사용해 변수에 대입하면, 기본형과 참조형 모두 값을 복사하는 현상이다.

[보기 1]
```js
const array_A = [];
const array_B = [ ...array_A ];
const array_C = array_A.slice();
const array_D = Object.assign([], array_A);

const object_A = {};
const object_B = { ...object_A };
const object_C = Object.assign({}, object_A);
const object_D = JSON.parse(JSON.stringify(object_A));
```

## Shallow-Coppy

값을 대입연산자를 사용해 변수에 대입하면, 기본형의 경우 값을 복사하지만 참조형의 경우 값의 주소를 복사하는 현상이다.

[보기 1]
```js
const primitive_A = "A";
const primitive_B = primitive_A;

console.log(primitive_A); // "A"
console.log(primitive_B); // "A"

primitive_B = "B";

console.log(primitive_A); // "A"
console.log(primitive_B); // "B"
```

[보기 2]
```js
const object_A = { name = "A" };
const object_B = A;

console.log(object_A); // "A"
console.log(object_B); // "A"

object_B.name = "B";

console.log(object_A); // "B"
console.log(object_B); // "B"
```

[보기 3]
```js
const object = { title: "hello", numbers: [1, 2, 3, 4], };

const variable_A = object.title;
const variable_B = object.numbers;

object.title = "world";
object.numbers.unshift(0);

console.log(variable_A); // "world"
console.log(variable_B); // [0, 1, 2, 3, 4]
```
