# [1 회차 03.31.] 4, 5, 6, 7장


## 4장 변수


### 4-1 변수란

---

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.

**`변수[variable]`는** 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

**값의 위치를 가리키는 상징적인 이름**

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **`변수 이름(변수명)`**이라 하고, 변수에 저장된 값을 `**변수 값**`이라고 한다.

변수에 값을 저장하는 것을 **`할당[assignment](대입, 저장)`**이라 하고, 변수에 저장된 값을 읽어 들이는 것을 **`참조[reference]`**라 한다.

### **4-2 식별자**

---

변수 이름을 `**식별자[identifier]**`라고도 한다.

**식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.**

값은 메모리 공간에 저장되어 있고 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 한다. 이를 위해 **식별자는 어떤 값이 저장되어 있는** **메모리 주소를 기억(저장)해야 한다.**

![Untitled](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/cda1af61-1492-42c1-8f19-859df015cb2a)

### 4-3 변수 선언

---

`변수 선언`이란 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것이다.

변수를 사용하기 위해선 선언이 필요하다. **변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.**

> `var`은 선언단계와 초기화 단계가 동시에 일어난다.
`let`, `const`는 선언 단계와 초기화 단계가 분리되어 일어난다.
> 

변수를 선언한 이후, 값을 할당하지 않았다면 자바스크립트 엔진에 의해 `**undefined**`라는 값이 할당되어 초기화 된다.

```jsx
var score; // undefined가 할당되어 초기화
```

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

- 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 `undefined`를 할당해 초기화 한다.

만약 변수 선언을 하지않은 식별자에 접근하면 **`참조 에러[ReferenceError]`**가 발생한다.

### 4-4 변수 선언의 실행 시점과 변수 호이스팅

---

```jsx
console.log(score); // undefined
var score;          // 변순 선언문
```

이 코드에서 참조 에러가 발생 하지 않고 undefined가 출력된다. 그 이유는 **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**

자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 이처럼 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 특징을 `변수 호이스팅`이라한다.**

> 변수 선언뿐 아니라 모든 식별자(변수, 함수, 클래스)는 호이스팅 된다.
> 

### 4-5 값의 할당

---

```jsx
console.log(score); // undefined
var score;          // 변수 선언
score = 80;         // 값의 할당

console.log(score); // 80

console.log(count); // undefined
var count = 1;      // 변수 선언과 값의 할당
console.log(count); // 1
```

**변수 선언은 런타임 이전에 먼저 실행되지만 값을 할당은 런타임에 실행된다.**

변수 선언과 값의 할당을 같이 작성해도 자바스크립트 엔진은 2개로 나누어 각각 실행한다. 따라서 `undefined`가 할당되어 초기화된다.

![Untitled 1](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/d80defa6-7eb0-4ad7-ad0d-89cee515eb8e)

이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리에 값을 할당하는 것이 아닌 **새로운 메모리 공간을 확보하고 그 곳에 값을 저장한다.**

### 4-6 값의 재할당

---

```jsx
var score = 80; // 변수 선언과 값의 할당
score = 90;     // 값의 재할당
```

값의 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.

만약 **값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 `상수[constant]`라한다.**

이전 값의 메모리 공간에 재할당 값을 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 값을 저장한다.

이전 값은 불필요한 값이므로 가비지 콜렉터가 메모리 공간을 주기적으로 검사하여 불필요한 값을 메모리에서 자동 해제한다.

### 4-7 식별자 네이밍 규칙

---

식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 말한다. 식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.

- 특수문자를 제외한 `문자`, `숫자`, `언더스코어(_)`, `달러 기호($)`를 포함할 수 있다.
- 단, 특수문자를 제외한 `문자`, `언더스코어(_)`, `달러 기호($)` 로 시작해야한다.
- 예약어는 식별자로 사용할 수 없다.

4가지 유형의 네이밍 컨벤션이 자주 사용된다.

```jsx
// 카멜 케이스(camelCase)
var firstName;
// 스네이크 케이스(snake_case)
var first_name;
// 파스칼 케이스(PascalCase)
var FirstName;
// 헝가리안 케이스(typeHungarianCase)
var strFirstName; // type + 식별
```

## 5장 표현식과 문


### 5-1 값

---

**`값[value]`은 식(표현식)이 평가 되어 생성된 결과**를 말한다.

평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

```jsx
// 변수에는 10 + 20은 평가되어 숫자 값 30을 생성한다.
var sum = 10 + 20; // 30
```

예제의 `sum`에 할당 되는 것은 10 + 20이 아니라 평가된 **결과인 숫자 값 30**이다. 이처럼 **변수에는** **하나의 값이 할당된다.**

### 5-2 리터럴

---

`**리터럴[literal]`은 사람이 이해할 수 있는 `문자(아라비아 숫자, 알파벳, 한글 등)` 또는 `약속된 기호(’’, “”, ., [], {}, // 등)`를 사용해 값을  생성하는 표기법을 말한다.** 

자바스크립트 엔진은 **런타임에 리터럴을 평가해 값을 생성한다.**

![Untitled 2](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/288e71d8-aae7-4dba-a2c5-985a75822c68)

### 5-3 표현식

---

**`표현식[expression]`은 `값`으로 평가될 수 있는 `문[statement]`이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**

리터럴, 식별자, 연산자, 함수 호출과 같은 다양한 표현식이 있지만 모두 값으로 평가된다. 즉 **값으로 평가될 수 있는 `문`은 모두 `표현식`이다.**

### 5-4 문

---

**`문[statement]`은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.** 문의 집합으로 이뤄진 것이 프로그램이며 문을 작성하고 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성된다. **`토큰[token]`이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.**

![Untitled 3](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/97b75447-2a70-4c55-8fcc-0d7417bc428d)

### 5-5 세미콜론과 세미콜론 자동 삽입 기능

---

`세미콜론(;)`은 문의 종료를 나타낸다. 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 따라서 문을 끝낼 때는 세미콜론을 붙여야한다.

자바스크립트는 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 `**세미콜론 자동 삽입 기능**`이 수행된다.

### 5-6 표현식인 문과 표현식이 아닌 문

---

표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수 있다.

**표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 변수에 할당해 보는 것이다.**

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
// 변수 선언문을 표현식이 아닌 문이다.
var x;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var y = var z; // 에러 발생

// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;
```

## 6장 데이터 타입


데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트는 7개의 데이터 타입을 제공한다. 7개의 데이터 타입은 `원시 타입`과 `객체 타입`으로 분류할 수 있다.

![Untitled 4](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/52cfda1c-1c59-41cc-980f-fd7601a78d63)

### 6-1 숫자 타입

---

자바스크립트는 하나의 숫자 타입만 존재한다. 

숫자 타입의 값은 배정밀도 64비트 부동 소수점 형식을 따른다. 즉 모든 수를 실수로 처리한다.

```jsx
// 모두 숫자 타입이다.
var integer = 10;   // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수
```

자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다.

```jsx
// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0);    // Infinity: 양의 무한대
console.log(10 / -0);   // -Infinity: 음의 무한대
console.log(1 * 'str'); // NaN: 산술 연산 불가(not-a-number)
```

### 6-2 문자열 타입

---

문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열은 0개 이상의 16비트 유닠호드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.

문자열은 `**작은따옴표(’ ’)**`, `**큰따옴표(” “)**`, `**백틱(` `)**`으로 텍스트를 감싼다. 텍스를 감싸지 않는 다면 식별자로 인식한다.

```jsx
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱
string = str;      // 식별자 str로 인식
```

### 6-3 템플릿 리터럴

---

템플릿 리터럴은 ES6부터 도입 되었다. `**멀티라인 문자열**`, **`표현식 삽입`**, `**태그드 탬플릿**` 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

템플릿 리터럴은 **`백틱(` `)`**을 사용해 표현한다.

### 6-4 불리언 타입

---

불리언 타입의 값은 논리적 참, 거짓을 나타내는 `true`와 `false`뿐이다.

```jsx
var foo = true;
console.log(foo); // true
foo = false;
console.log(foo); // false
```

### 6-5 undefined 타입

---

`undefined`타입의 값은 `undefined`가 유일하다.

변수를 선언하 이후 값을 할당하지 않으면 자바스크립트는 `undefined`로 초기화 한다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 `undefined`가 반환된다.

### 6-6 null 타입

---

`null`타입의 값은 `null`이 유일하다. 자바스크립트는 대소문자를 구별하므로 `null`은 `Null`, `NULL` 등과 다르다.

프로그래밍 언어에서 `null` 은 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다.

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null` 을 반환하기도 한다.

### 6-7 심벌 타입

---

**`심벌[symbol]`**은 ES6에서 추가된 타입으로, 변경이 불가능한 원시 타입의 값이다. 다른 값과 중복 되지 않는 유일무이한 값이다. 따라서 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

```jsx
var key = Symbol('key');
console.log(typeof key); // symbol
```

### 6-8 객체 타입

---

자바스크립트는 객체 기반의 언어이며, **자바스크립트를 이루고 있는 거의 모든 것이 객체**라는 것이다.

### 6-9 데이터 타입을 필요성

---

1. 값을 저장할때 테이터 타입에 의한 메모리 공간의 확보와 참조
2. 값을 참조할때 한 번에 읽어 들여야 할 메모리 공간의 크기를 알아야 할때
3. 메모리에서 읽어 들인 2진수를 어떻게 해석하기 위해

### 6-10 동적 타이핑

---

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.

이런 `**동적 타입 언어**`는 유연성이 높지만 신뢰성이 떨어진다.

## 7장 연산자


연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해서 **하나의 값을 만든다.**

```jsx
// 산술 연산자
5 * 4 // = 20

// 문자열 연결 연산자
'My name is ' + 'Lee' // 'My name is Lee'

// 할당 연산자
color = 'red' // = 'red'

// 비교 연산자
3 > 5 // = false

// 논리 연산자
true && false // = false

// 타입 연산자
typeof 'Hi' // = string
```

### 7-1 산술 연산자

---

피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.

불가능한 경우 `**NaN**`을 반환한다.

```jsx
// 이항 산술 연산자
5 + 2; // -> 7
5 - 2; // -> 3

// 당항 산술 연산자
var x = 1;
x++; // x = x + 1;
console.log(x); // 2
```

### 7-2 할당 연산자

---

우항에 있는 피연산자의 평가 결과를 좌항의 변수에 할당한다.

```jsx
var x;

x = 10;
console.log(x); // 10

x += 5; // x = x + 5;
console.log(x); // 15

x -= 5; // x = x - 5;
console.log(x); // 10
```

### 7-3 비교 연산자

---

좌항과 우항의 피연산자를 비교 후 불리언 값으로 변환한다.

동등 비교(==)는 피연산자를 암묵적 타입 변환을 통해 타입을 일치 시킨 후 값을 비교한다.

일치 비교(===)는 타입과 값 모두를 비교한다.

동등 비교 연산자는 예측하기 어려운 결과를 만들어낸다. 따라서 동등 비교 연산자는 사용하지 않고 일치 비교 연산자를 사용한다.

```jsx
// 동등 비교. 결과를 예측하기 어렵다.
'0' == ''; // -> false
0 == '';   // -> true
0 == '0';  // -> true
false == 'false';   // -> false
false == '0';       // -> true
false == null;      // -> false
false == undefined; // -> false

// 일치 비교
5 === 5; // -> true
5 === '5'; // -> false

// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // -> false
```

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

### 7-4 삼항 조건 연산자

---

조건식의 평가 결과 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 조건 연산자이며, 부수 효과는 없다.

if … else 문과 유사하지만 중요한 차이점이 있다. 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만 if … else 문은 값처럼 사용할 수 없다.

**`삼항 조건 연산자` 표현식은 값으로 평가할 수 있는 표현식 문이다.**

```jsx
// 조건식 ? 조건이 true일 때 반환할 값 : 조건이 false 일 때 반환할 값 
var score = 60;

var result = score >= 60 ? 'pass' : 'fail';
```

### 7-5 논리 연산자

---

논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다. 

![Untitled 5](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/92ef7ac8-feea-40f1-840f-ec4eb4fbce05)

```jsx
// 논리합(||) 연산자
true || true; // = true
true || false; // = true
false || false; // = false

// 논리곱(&&) 연산자
true && true; // = true
true && false; // = false
false && false; // = false

// 부정(!) 연산자
!true; // = false
!false; // = true
```

### 7-6 쉼표 연산자

---

`쉼표(,)` 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 결과를 반환한다.

```jsx
var x, y, z;

x = 1, y = 2, z = 3; // 3
```

### 7-7 그룹 연산자

---

`소괄호('()')`로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장먼저 평가한다.

그룹 연산자는 연산자 우선순위가 가장 높다.

```jsx
10 * 2 + 3; // = 23

// 그룹 연산자를 사용하여 우선순위를 조절
10 * (2 + 3); // = 50
```

### 7-8 typeof 연산자

---

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

```jsx
typeof ''            // = string
typeof 1             // = number
typeof NaN           // = number
typeof true          // = boolean
typeof undefined     // = undefined     
typeof Symbol()      // = object
typeof null          // = object
typeof []            // = object
typeof {}            // = object
typeof new Date()    // = object
typeof /test/gi      // = object
typeof function() {} // = function
```

### 7-9 지수 연산자

---

ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.

```jsx
2 ** 2;   // = 4
2 ** 2.5; // = 5.656..
2 ** 0;   // = 1
2 ** -2;  // = 0.25

// 음수를 거듭제곱의 밑으로 계산하려면 괄호로 묶어야 한다.
(-5) ** 2; // = 25
```

### 7-11 연산자의 부수 효과

---

일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.

부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산(++/--), delete 연산자 다.

### 7-12 연산자 우선순위

---

연산자 우선순위란 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서를 말한다.

우선순위가 높을수록 먼저 실행된다.

![Untitled 6](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/35f8eb10-a090-4e57-9091-e2d2133bddf5)

### 7-13 연산자 결합 순서

---

연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지 나타내는 순서를 말한다.

![Untitled 7](https://github.com/wjsdncl/study-javascript-deep-dive/assets/89517903/c9fed8f5-c839-4de9-a143-28e3894258b3)
