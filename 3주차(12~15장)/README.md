### 12.4.1 함수 선언문

---

```jsx
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir은 console.log와는 달리 함수 객체의 프로퍼티까지 출력한다.
// 단, Node.js 환경에서는 console.log와 같은 결과가 출력된다.
console.dir(add); // ƒ add(x, y)

// 함수 호출
console.log(add(2, 5)); // 7
```

`함수 선언문`은 `함수 리터럴`과 형태가 동일하지만 `**함수 선언문`은 함수 이름을 생략할 수 없습니다.**

`**함수 선언문`은 표현식이 아닌 문**입니다.

```jsx
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};

// 함수 호출
console.log(add(2, 5)); // 7
```

자바스크립트 엔진은 동일한 코드도 코드의 문맥에 따라 해석이 달라질 수 있습니다.

예를들어, 코드블록`{ }`은 **`블록문`**일 수도 있고**`객체 리터럴`**일 수도 있습니다.
즉 `{ }`은 중의적 표현입니다.

`{ }`이 단독으로 존재하면 `{ }`을 **`블록문`으로 해석**합니다.
`{ }`이 값으로 평가되어야 할 문맥(예, 할당연산자의 우변)에서 피연산자로 사용되면 `{ }`을 `**객체 리터럴`로 해석**한다.

함수 리터럴도 중의적인 코드여서 코드의 문맥에 따라 해석이 달라질 수 있습니다.

함수 이름이 있는 함수 리터럴을 단독으로 사용하면(함수 리터럴을 피연산자로 사용하지 않는 경우) **`함수 선언문`으로 해석**합니다.
함수 리터럴이 값으로 평가어야 하는 문맥(변수를 할당하거나 피연산자로 사용하는 경우)에따라 **`함수 리터럴 표현식`으로 해석**합니다.

```jsx
//  add: 식별자     add: 함수 이름
var add = function add(x,y){
  return x+y;
};
//          add: 식별자
console.log(add(2,5)); // 7
// 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
```

**자바스크립트 엔진은 생성된 `함수`를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당합니다.**

**`함수`는 `함수 이름`으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.**

즉 함수 선언문으로 생성한 함수를 호출한 것은 함수 이림 add가 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것입니다.

`함수 이름`과 `변수 이름`이 일치하므로 `함수 이름`으로 호출되는 듯하지만 사실은 `**식별자`로 호출**된 것입니다.
