# 40장 이벤트

### 40.1 이벤트 드리븐 프로그래밍

이벤트 핸들러: 이벤트가 발생했을 때 호출될 함수
이벤트 핸들러 등록: 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것
이벤트 드리븐 프로그래밍: 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식

### 40.2 이벤트 타입

### 40.3 이벤트 핸들러 등록
##### 40.3.1 이벤트 핸들러 어트리뷰트 방식
이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.

##### 40.3.2 이벤트 핸들러 프로퍼티 방식
이벤트 핸들러 등록을 위해서는 이벤트 타깃, 이벤트 타입, 이벤트 핸들러를 지정할 필요가 있다.

##### 40.3.3 addEventListener 메서드 방식
하나 이상의 이벤트 핸들러 등록이 가능하다.

### 40.4 이벤트 핸들러 제거

### 40.5 이벤트 객체
이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.

##### 40.5.1 이벤트 객체의 상속 구조

이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체도 생성자 함수에 의해 생성된다. 그리고 생성된 이벤트 객체는 생성자 함수와 더불어 생성되는 프로토타입으로 구성된 프로토타입 체인의 일원이 된다.

##### 40.5.2 이벤트 객체의 공통 프로퍼티

Event 인터페이스, 즉 Event.prototype에 정의되어 있는 이벤트 관련 프로퍼티는 UIEvent, CustomEvent, MouseEvent 등 모든 파생 이벤트 객체에 상속된다. 

##### 40.5.3 마우스 정보 취득
##### 40.5.4 키보드 정보 취득

### 40.6 이벤트 전파
생성된 이벤트 객체는 이벤틀르 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파된다.

- 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계: 이벤트가 이벤트 타깃에 도달
- 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파

### 40.7 이벤트 위임
여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.

### 40.8 DOM 요소의 기본 동작 조작
##### 40.8.1 DOM 요소의 기본 동작 중단
preventDefault 메서드는 DOM 요소의 기본 동작을 중단시킨다.

##### 40.8.2 이벤트 전파 방지
stopProgagtion 메서드는 이벤트 전파를 중지시킨다.

### 40.9 이벤트 핸들러 내부의 this
##### 40.9.1 이벤트 핸들러 어트리뷰트 방식
이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

##### 40.9.2 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식
이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.

### 40.10 이벤트 핸들러에 인수 전달

### 40.11 커스텀 이벤트

##### 40.11.1 커스텀 이벤트 생성
커스텀 이벤트 객체는 버블링 되지 않으며 preventDefault 메서드로 취소할 수도 없다.

##### 40.11.2 커스텀 이벤트 디스패치 
생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치(이벤트를 발생시키는 행위)를 할 수 있다.

# 41장 타이머

### 41.1 호출 스케일링
함수를 명시적으로 호출하지 않고 일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약하려면 타이머 함수를 사용한다. 이를 호출 스케줄링이라 한다.

타이머 함수는 빌트인 함수가 아니고 호스트 객체이다. 

- 호스트 객체: 실행 환경에서 제공하는 객체(OS, Web brower에 따라 제공 객체가 달라짐)
- 네이티브 객체: 자바스크립트 언어 규약(ECMAScript)으로 정의되어진 객체. 애플리케이션 전역의 공통 기능을 제공한다. 네이티브 객체는 애플리케이션의 환경과 관계없이 언제나 사용할 수 있다.

자바스크립트 엔진은 싱글 스레드로 동작하기 때문에 setTimeout과 setInterVal은 비동기 처리 방식으로 동작한다.

### 41.2 타이머 함수
##### 41.2.1 setTimeout/clearTimeout

```
const timeoutID = setTimeout(func|code[, delay, param1, param2, ...]);
```
setTimeout 함수는 타이머를 식별할 수 있는 고유한 id를 반환한다.

```
const timerId = setTimeout(() => console.log('HI!'), 1000);

clearTimeout(timerId);
```
clearTimeout 함수는 호출 스케줄링을 취소한다.

### 41.3 디바운스와 스로틀
scroll, resize, input, mousemove 같은 이벤트는 짧은 시간 간격으로 연속해서 발생하기 때문에 성능에 문제를 줄 수 있다.

디바운스와 스로틀은 짧은 시간안에 여러번 발생하는 이벤트들을 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다.


##### 41.3.1 디바운스
짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트가 호출되도록 한다.

resize 이벤트 처리나 input 요소의 입력된 값으로 ajax 요청하는 입력 필드 자동완성, 버튼 중복 클릭 방지 처리등에 사용한다.


##### 41.3.2 스로틀
짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 최대 한 번만 호출되도록 한다.

delay 시간이 경과했을 때 이벤트가 발생하면 콜백 함수를 호출하고 새로운 타이머를 재설정한다. 따라서 delay 시간 간격으로 콜백함수가 호출된다. 이는 scroll 이벤트 처리나 무한 스크롤 구현 등에 유용하게 사용된다.

# 42장 비동기 프로그래밍

### 42.1 동기 처리와 비동기 처리

JS엔진은 하나의 실행 컨텍스트(콜 스택) 스택을 갖기 때문에 2개 이상의 함수를 동시에 실행할 수 없다. (싱글 스레드)

이 싱글 스레드는 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다.

- 동기 처리: 실행 중인 태스크가 종료할 때 까지 다음에 실행될 태스크가 대기하는 방식
- 비동기 처리: 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식

### 42.2 이벤트 루프와 태스크 큐

이벤트 루프는 자바스크립트의 동시성을 지원하는 것이다.

- 콜 스택: 실행 컨텍스트 스택을 말하며 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지 다른 어떤 태스크 실행 X

- 힙: 객체가 저장되는 메모리 공간, 객체는 크기가 정해져 있지 않아서 메모리 공간의 크기를 런타임에 결정하며 구조화 되어있지 않다는 특징을 가지고 있음.

비동기 처리의 코드 평가와 실행을 제외한 모든 처리는 JS엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다.(호출 스케줄링을 위한 타이머 설정 및 콜백 함수 등록 --> 브라우저 또는 Node.js가 담당한다.)

- 태스크 큐: setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

- 이벤트 루프: 콜 스택에 현재 실행중인 실행컨텍스트가 존재하는 지 확인하고, 콜스택이 비어있고 태스크 큐에 대기 중인 함수가 존재 시, 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.

**비동기 함수인 setTimeout의 콜백 함수는 태스크 큐에 푸시되어 대기 후, 콜 스택이 비게되면 그때 콜스택에 들어가 실행된다.(브라우저가 타이머 만료되면 콜백 함수를 태스크 큐에 등록해줌)**

**따라서 JS엔진은 싱글스레드로, 브라우저는 멀티 스레드로 동작한다.**






# 43장 Ajax
### 43.1 Ajax란?

JS를 사용해서 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식이다.

Web Api인 XMLHttpRequest 객체를 기반으로 동작하며 이 객체는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.

**Ajax 통신의 장점**

- 필요한 데이터만 서버로부터 전송 받아서 효율적
- 변경할 필요가 없는 부분 재 랜더링X -> 순간적으로 깜박이는 현상 없음
- 클라이언트와 서버의 통신이 비동기적으로 동작하여 요청을 보낸 후에 블로킹이 발생하지 않는다.

### JSON
JSON은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다.

##### 43.2.1 JSON의 표기 방식
JS의 객체 리터럴과 유사하게 키와 값으로 구성된 순수한 텍스트이다.

키는 무조건 큰 따옴표로 묶고, 값 중에서 문자열은 반드시 큰 따옴표로 묶어야한다.

##### 43.2.2 JSON.stringify
이 메서드는 객체를 JSON 포맷의 문자열로 변환한다.

클라이언트가 서버로 객체를 전송하려면 객체를 문자열화 해야하며 이를 직렬화라고 한다.

##### 43.2.3 JSON.parse
JSON 포맷의 문자열을 객체로 변환한다. 서버로부터 받은 JSON 데이터를 객체로 사용하려면 JSON문자열을 객체화 하여 사용한다.

### 43.3 XMLHtppRequest
JS를 사용하여 HTTP 요청을 전송하려면 XMLHttpRequest 객체를 사용한다. 이 객체는 HTTP 요청 전송 및 응답 수신을 위한 다양한 메서드와 프로퍼티를 제공한다.

##### 43.3.1 XMLHttpRequest 객체 생성
Web API 이므로 브라우저 환경에서만 정상적으로 실행된다.

##### 43.3.2 XMLHttpRequest 객체의 프로퍼티와 메서드

**XMLHttpRequest 객체의 프로토타입 프로퍼티**
| 프로토타입 프로퍼티 | 설명                                                                                                                                                  |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| readyState         | HTTP 요청의 현재 상태를 나타내는 정수. (UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4)                                             |
| status             | HTTP 요청에 대한 응답 상태를 나타내는 정수                                                                                                          |
| statusText         | HTTP 요청에 대한 응답 메시지를 나타내는 문자열                                                                                                      |
| responseType       | HTTP 응답 타입                                                                                                                                      |
| response           | HTTP 요청에 대한 응답 몸체. responseType에 따라 타입이 다름                                                                                         |

**XMLHttpRequest 객체의 이벤트 핸들러 프로퍼티**
| 이벤트 핸들러 프로퍼티 | 설명                                                           |
|-----------------------|----------------------------------------------------------------|
| onreadystatechange    | readyState 프로퍼티 값이 변경된 경우                          |
| onerror               | HTTP 요청에 에러가 발생한 경우                                |
| onload                | HTTP 요청이 성공적으로 완료한 경우                            |

**XMLHttpRequest 객체의 메서드**
| 메서드               | 설명                                                       |
|----------------------|------------------------------------------------------------|
| open                 | HTTP 요청 초기화                                           |
| send                 | HTTP 요청 전송                                             |
| abort                | 이미 전송된 HTTP 요청 중단                                 |
| setRequestHeader     | 특정 HTTP 요청 헤더의 값을 설정                             |

**XMLHttpRequest 객체의 정적 프로퍼티**
| 정적 프로퍼티 | 값 | 설명              |
|---------------|-----|-----------------|
| DONE          | 4   | 서버 응답 완료   |

##### 43.3.3 HTTP 요청 전송
1. open 메서드로 HTTP 요청 초기화
2. setRequestHeader 메서드로 특정 HTTP 요청의 헤더 값 설정
3. send 메서드로 HTTP 요청 전송

**XMLHttpRequest.prototype.open**
서버에 전송할 HTTP 요청을 초기화한다.
| 메서드              | 설명                                                       |
|---------------------|------------------------------------------------------------|
| open(method, url, async) | HTTP 요청 초기화 (HTTP 요청 메서드: GET/POST/PUT/DELETE, URL: HTTP 요청을 전송할 URL, 비동기 요청 여부: 기본값은 true) |
| send                | HTTP 요청 전송                                             |
| abort               | 이미 전송된 HTTP 요청 중단                                 |
| setRequestHeader    | 특정 HTTP 요청 헤더의 값을 설정                             |

HTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적을 알리는 방법이다.
| HTTP 요청 메서드 | 종류         | 목적                       | 페이로드 |
|------------------|--------------|----------------------------|----------|
| GET              | index/retrieve | 모든/특정 리소스 취득      | X        |
| POST             | create       | 리소스 생성                | O        |
| PUT              | replace      | 리소스의 전체 교체         | O        |
| PATCH            | modify       | 리소스의 일부 수정         | O        |
| DELETE           | delete       | 모든/특정 리소스 삭제      | X        |

**XMLHttpRequest.prototype.send**

send 메서드는 open 메서드로 초기화된 HTTP 요청을 서버에 전송한다.

- GET 요청 메서드의 경우 데이터를 URL의 일부분인 쿼리 문자열로 서버에 전송한다.
- POST 요청 메서드의 경우 데이터(페이로드)를 요청 몸체에 담아 전송한다.
페이로드가 객체인 경우 반드시 JSON.stringify 메서드를 사용하여 직렬화한 다음 전달해야 한다.

**HTTP 요청 메서드가 GET 인 경우 send 메서드에 페이로드로 전달한 인수는 무시되고 요청 몸체는 null로 설정된다.**

**XMLHttpRequest.prototype.setReuqestHeader**

특정 HTTP 요청의 헤더 값을 설정한다.

Content-type은 요청 몸체에 담아 전송할 데이터의 MIME 타입의 정보를 표현한다.

자주사용 되는 MIME 타입은 다음과 같다.
| MIME 타입    | 서브타입                                       |
|--------------|------------------------------------------------|
| text         | text/plain, text/html, text/css, text/javascript|
| application  | application/json, application/x-www-form-urlencoded |
| multipart    | multipart/form-data                            |

##### 43.3.4 HTTP 응답 처리

readystatechange 이벤트를 활용하면 된다.
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const xhr = new XMLHttpRequest();

      xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1');

      xhr.send();

      xhr.onreadystatechange = () => {
        if (xhr.readyState !== XMLHttpRequest.DONE) return;

        if (xhr.status === 200) {
          console.log(JSON.parse(xhr.response));
        } else {
          console.error('Error', xhr.status, xhr.statusText);
        }
      };
    </script>
  </body>
</html>
```
