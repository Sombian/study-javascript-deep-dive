# 40장\_이벤트

## 이벤트 드리븐 프로그래밍

> 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 **이벤트를 발생시킨다.**

**이벤트 핸들러**

이벤트가 발생했을 때 호출될 함수

**이벤트 핸들러 등록**

이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것

## 이벤트 타입

MDN 찾아보자

[Event reference | MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

## 이벤트 핸들러 등록

> 이벤트가 발생했을 때, 브라우저에게 이벤트 핸들러의 호출을 위임하는 것

등록하는 방법은 총 3가지이다.

### 이벤트 핸들러 어트리뷰트 방식

HTML 요소의 어트리뷰트 중에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 있다.

on 접두사, 이벤트 타입으로 이루어져 있다.

함수 호출문 등의 문을 할당하면 이벤트 핸들러가 등록된다.

이벤트 핸들러 어트리뷰트 값으로함수 참조가 아닌 함수 호출문 등의 문을 할당한다.

**이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.**

오래된 방식이니 사용하지 말자.

### 이벤트 핸들러 프로퍼티 방식

DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다.

on 접두사, 이벤트 타입으로 이루어져 있다.

이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다.

이벤트 핸들러를 등록하기 위해서, 이벤트 타깃(이벤트를 발생시킬 객체), 이벤트 타입(이벤트의 종류를 나타내는 문자열), 이벤트 핸들러를 지정할 필요가 있다.

HTML과 자바스크립트가 뒤섞이는 문제를 해결할 수 있지만, 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.

### addEventListener 메서드 방식

DOM Level 2에서 도입되었다.

이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무런 영향도 주지 않는다.

버튼 요소에서 클릭 이벤트가 발생하면 2개의 핸들러가 모두 호출되며 등록 순서대로 호출된다.

## 이벤트 핸들러 제거

removeEventListener 메서드를 사용한다.

addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않는다.

무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없으며 제거하려면 이벤트 핸들러의 참조를 변수나 자료구조에 저장하고 있어야 한다.

## 이벤트 객체

이벤트가 발생하면 이벤트 객체가 동적으로 생성된다.

**생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.**

이벤트 객체를 전달받으려면 이벤트 핸들러를 정의할 때 이벤트 객체를 전달받은 매개변수를 명시적으로 선언해야 한다.

## 이벤트 전파

DOM 트리를 통해 전파된다.

생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파된다.

1. 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
2. 타깃 단계: 이벤트가 이벤트 타깃에 도달
3. 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파

→ 이벤트를 발생시킨 이벤트 타깃과 상위 DOM 요소에서도 캐치할 수 있다.

## 이벤트 위임

하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.

## DOM 요소의 기본 동작 조작

기본 동작 중단, 이벤트 전파 방지 등이 가능하다.

## 이벤트 핸들러 내부의 this

### 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

⇒ 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.

## 이벤트 핸들러에 인수 전달

## 커스텀 이벤트

# 41장\_타이머

## 호출 스케일링

> 함수를 명시적으로 호출하지 않고 일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약하려면 타이머 함수를 이용한다.
> 이를 호출 스케일링이라고 한다.

ECMAScript 사양에 정의된 빌트인 함수가 아니지만, 브라우저 환경과 node.js 환경에서 모두 전역 객체의 메서드로서 타이머 함수를 제공한다. 즉, 호스트 객체이다.

**자바스크립트 엔진은 싱글 스레드로 동작하므로, 타이머 함수 setTimeout과 setInterval은 비동기 처리 방식으로 동작한다.**

## 타이머 함수

### **setTimeout/clearTimeout**

setTimeout 함수는 두 번째 인수로 전달받은 시간으로 단 한 번 동작하는 타이머를 생성한다.

이후 타이머가 만료되면 첫 번째 인수로 전달받은 콜백 함수가 호출된다.

```tsx
const timeoutId = setTimeout((name) => console.log(`Hi! ${name}`), 1000, "Lee");

//1초(1000ms) 후 타이머가 만료되면 콜백함수가 호출되며 Lee가 인수로 전달된다.
```

setTimeout 함수는 생성된 타이머를 식별할 수 있는 고유한 타이머 id를 반환한다.

이렇게 반환한 타이머 id는 브라우저 환경인 경우 숫자. Node.js의 경우 객체다.

이 id를 clearTimeout 함수의 인수로 전달해 타이머를 취소할 수 있다.

clearTimeout은 호출 스케줄링을 취소한다.

### **setInterval / clearInterval**

setInterval 함수는 두 번째 인수로 전달 받은 시간(ms, 1/1000초)로 반복동작하는 타이머를 생성한다.

이후 만료될 때마다 취소될 때까지 parameter로 전달받은 콜백함수가 반복 호출된다.

setInterval 함수 역시 생성된 타이머를 식별할 수 있는 고유한 타이머 id를 반환한다.

반환한 타이머 id는 브라우저 환경인 경우 숫자. Node.js의 경우 객체다.

이 id를 clearTimeout 함수의 인수로 전달해 타이머를 취소할 수 있다.

clearTimeout은 호출 스케줄링을 취소한다.

## 디바운스와 스로틀

scroll, resize, input, mousemove와 같은 이벤트는 짧은 시간 간격으로 연속적으로 발생한다.

위와 같은 이벤트에 바인딩한 이벤트 핸들러는 과도하게 호출되어 문제를 일으킬 수 있다.

**디바운스와 스트롤은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다.**

### 디바운스

짧은 시간 간격으로 이벤트가 연속해서 발생하면, 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후에 이벤트 핸들러가 한 번만 호출되도록 한다.

짧은 시간 간격으로 발생한 이벤트를 그룹화해서 마지막에 한 번만 호출되도록 한다.

### 스로틀

짧은 시간 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다.

짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화, 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.

# 42장\_비동기 프로그래밍

## 동기 처리와 비동기 처리

함수를 호출하면 함수 코드가 평가되어 함수 실행 컨텍스트가 생성된다.

이때 생성된 함수 실행 컨텍스트는 실행 컨텍스트 스택(콜 스택)에 푸시되고 함수 코드가 실행된다.

함수 코드의 실행이 종료하면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.

함수의 실행 순서는 실행 컨텍스트 스택으로 관리한다.

**자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.**

자바스크립트 엔진은 싱글 스레드 방식으로 동작한다.

**처리에 시간이 걸리는 태스크를 실행하는 경우, 블로킹이 발생한다.**

현재 실행 중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식을 동기 처리라고 한다.

현재 실행 중인 태스크가 종료되지 않은 상태라 해도, 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라고 한다.

타이머 함수인 setTimeout, setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.

## 이벤트 루프와 태스크 큐

자바스크립트는 싱글 스레드 방식으로 동작하기 때문에 한 번에 하나의 태스크만 처리할 수 있지만, 브라우저가 동작하는 것을 보면 태스크가 동시에 처리되는 것처럼 느껴진다.

자바스크립트의 동시성을 지원하는 것을 이벤트 루프라고 한다.

자바스크립트 엔진은 크게 2개 영역으로 나눌 수 있다.

- 콜 스택 : 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 콜 스택이다.
- 힙 : 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.

비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 node.js가 담당한다.

예를 들어, 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다.

이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.

- 태스크 큐 : setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.
- 이벤트 루프 : 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다. 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 즉, **태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.**

자바스크립트 엔진은 싱글 스레드로 동작하지만, 브라우저는 멀티 스레드로 동작한다.

# 43장\_Ajax

## Ajax란?

Ajax(Asynchronous JavaScript And XML)란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고 수신하는 프로그래밍 방식이다.

Ajax는 브라우저에서 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작한다.

XMLHttpRequest는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.

전통적인 웹페이지의 단점은 다음과 같다.

- 변경 사항이 없는 파일도 매번 다시 전송받기 때문에 불필요한 데이터 통신이 발생한다.
- 변경할 필요가 없는 부분도 다시 렌더링되어 화면 전환이 일어나면 깜박이는 현상이 발생한다.
- 통신이 동기적으로 이루어지기 때문에 블로킹 현상이 일어난다.

Ajax가 해결한 단점은 다음과 같다.

- 변경할 부분을 갱신하는 데 필요한 데이터만 전송받아 불필요한 데이터 통신이 발생하지 않는다.
- 변경할 필요가 없는 부분은 다시 렌더링되지 않기 때문에 화면이 깜박이는 현상이 발생하지 않는다.
- 통신이 비동기적으로 이루어지기 때문에 블로킹이 발생하지 않는다.
- 즉, 변경 사항이 있는 데이터만 비동기 방식으로 전송받아 불필요한 렌더링이 일어나지 않고 빠른 퍼포먼스와 부드러운 화면 전환이 가능해졌다.

## JSON

클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다.

### J**SON 표기 방식**

객체 리터럴과 유사한, 키와 값으로 구성된 순수한 텍스트이다.

```tsx
{
	"name": "Lee",
    "age": 20,
    "alive": true
}
```

### **JSON.stringify**

JSON.stringify 메서드는 객체나 배열을 JSON 포맷의 문자열로 변환한다.

클라이언트가 서버로 객체를 전송하려면 객체를 문자열화해야 하는데 이를 직렬화라 한다.

### **JSON.parse**

JSON.parse 메서드는 JSON 형식의 문자열을 객체나 배열로 변환한다.

서버로부터 클라이언트에 전송된 JSON 데이터는 문자열이다.

이 문자열을 객체로서 사용하려면 JSON 포맷의 문자열을 객체화해야 하는데 이를 역직렬화라 한다.
