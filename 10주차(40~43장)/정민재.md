# [10회차 06.02.] 40, 41, 42, 43장

# **40장 이벤트**

## **40.1 이벤트 드리븐 프로그래밍**

이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러**라 함

이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 함

이벤트와 그에 대응하는 함수를 통해 사용자와 애플리케이션은 상호작용을 할 수 있으며 이와 같이 **프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍**이라 함

## **40.2 이벤트 타입**

### **40.2.1 마우스 이벤트**

| 이벤트 타입 | 이벤트 발생시점 |
| --- | --- |
| click | 마우스 버튼 클릭 시 |
| dblclick | 마우스 버튼을 더블 클릭 했을 시 |
| mousedown | 마우스 버튼을 눌렀을 때 |
| mouseup | s누르고 있던 마우스 버튼을 놓았을 때 |
| mousemove | 마우스 커서를 움직였을 때 |
| mouseenter | 마우스 커서를 html 요소 안으로 이동했을 때(버블링 되지 않음) |
| mouseover | 마우스 커서를 html 요소 안으로 이동했을 때(버블링 됨) |
| mouseleave | 마우스 커서를 html 요소 밖으로 이동했을 때(버블링 되지 않음) |
| mouseout | 마우스 커서를 html 요소 밖으로 이동했을 때(버블링 됨) |

### **40.2.2 키보드 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 |
| --- | --- |
| keydown | 모든 키를 눌렀을 때 발생 |
| keypress | 문자 키를 눌렀을 때 연속으로 발생 |
| keyup | 누르고 있던 키를 놓았을 때 한번만 발생 |

### **40.2.3 포커스 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 | 버블링 |
| --- | --- | --- |
| focus | html 요소가 포커스를 받았을때 | X |
| blur | html 요소가 포커스를 잃었을때 | X |
| focusin | html 요소가 포커스를 받았을 때 | O |
| focusout | html 요소가 포커스를 잃었을 때 | O |

### **40.2.4 폼 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 |
| --- | --- |
| submit | form 요소 내의 submit 버튼을 클릭했을 때 |
| reset | form 요소 내의 reset 버튼을 클릭했을 때(최근에는 사용 X) |

### **40.2.5 값 변경 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 |
| --- | --- |
| input | input, select, textarea 요소의 값이 입력 됐을 때 |
| change | input, select, textarea 요소의 값이 변경 됐을 때 |
| readystatechange | html 문서의 로드와 파싱 상태를 나타내는 readyState(loading, interactive, complate) 프로퍼티 값 이 변경 되었을 때 |

### **40.2.6 DOM 뮤테이션 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 |
| --- | --- |
| DOMContentLoaded | html 문서의 로드와 파싱이 완료되어 DOM 생성이 완료 되었을 때 |

### **40.2.7 뷰 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 |
| --- | --- |
| resize | 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생함 |
| scroll | 웹페이지 또는 html 요소를 스크롤 할때 발생 함 |

### **40.2.8 리소스 이벤트**

| 이벤트 타입 | 이벤트 발생 시점 |
| --- | --- |
| load | DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스의 로딩이 완료 되었을 때 |
| unload | 리소스가 언로드 될 때 |
| abort | 리소스 로딩이 중단되었을 때 |
| error | 리소스 로딩이 실패했을 때 |

## **40.3 이벤트 핸들러 등록**

### **40.3.1 이벤트 핸들러 어트리뷰트 방식**

이벤트 핸들러 어트리뷰트의 이름은 onclick과 같이 on 접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이뤄져 있다.
이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문을 할당하면 이벤트 핸들러가 등록된다.

주의할 점은 이벤트 핸들러 어트리뷰트 값으로 함수 참조가 아닌 함수 호출문 등의 문을 할당한다는 것이다.

이벤트 핸들러 어트리뷰트 값으로 함수 호출문을 할당했다.
이때, **이벤트 핸들러 어트리뷰트의 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미** 한다.

이처럼 동작하는 이유는 이벤트 핸들러에 인수를 전달하기 위하서 이다.
이벤트 핸들러 어트리뷰트 값으로 함수 참조를 할당해야 한다면 이벤트 핸들러에 인수를 전달하기 곤란하다.

### **40.3.2 이벤트 핸들러 프로퍼티 방식**

window객체, Document, HTMLElement 타입의 DOM노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다.

onclick과 같이 on접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이루져 있는다.

함수를 바인딩하면 이벤트 핸들러가 등록된다.

이벤트 핸들러를 등록하기 위해서는
이벤트를 발생시킬 객체인 **이벤트 타깃**과
이벤트 종류를 나타내는 문자열인 **이벤트 타입**
그리고 **이벤트 핸들러를 지정**해야 한다.

이벤트 핸들러는 대부분 이벤트를 발생시킬 이벤트 타깃에 바인딩한다.
하지만 반드시 바인딩 해야 하는 것은 아니다.
이벤트 핸들러는 이벤트 타깃 또는 전파된 이벤트를 캐치할 DOM노드 객체에 바인딩한다.

### **40.3.3 addEventListener 메서드 방식**

addEventListener 메서드를 사용하여 이벤트 핸들러를 등록할 수 있다.

동일한 HTML 요소에서 발생한 동일한 이벤트에 대해 addEventListener 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다.
이때 이벤트 핸들러는 등록된 순서대로 호출된다.

## **40.4 이벤트 핸들러 제거**

등록한 핸들러를 제거 하려면 removeEventListener 메서드를 사용한다.
addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거 되지 않는다.

## **40.5 이벤트 객체**

이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다.
**생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달** 된다

### **40.5.1 이벤트 객체의 상속 구조**

이벤트가 발생하면 타입에 따라 다양한 타입의 이벤트 객체가 생상된다.

### **40.5.2 이벤트 객체의 공통 프로퍼티**

Event 인터페이스, 즉 Event.prorotype에 정의되어 있는 이벤트 관련 프로퍼티는 UIEvent, CustomEvent, MouseEvent 등 모든 파생 이벤트 객체에 상송 된단.
즉, Event 인터페이스의 이벤트 관련 프로터피는 모든 이벤트 객체가 상속받는 공통 프로퍼티다.

### **40.5.3 마우스 정보 취득**

click, dbclick, mousedown, mouseup, mousemove, mouseenter, mouseleave 이벤트가 발생하면 생성되는 MouseEvent 타입의 객체는 고유의 프로퍼티를 갖는다

- 마우스 포인트의 좌표 정보를 나타내는 프로퍼티: screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
- 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button

### **40.5.4 키보드 정보 취득**

keydown, keyup, keypress 이벤트가 발생하면 생성되는 keyboardEvent 타입의 이벤트 객체는 altKey, ctrlKey, shiftKey, metaKey, key, keyCode 같은 고유의 프로프티를 갖음

## **40.6 이벤트 전파**

DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다.
이를 이벤트 전파라 한다.

```
<ul id="fruits">
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="orange">Orange</li>
</ul>
```

ul 요소의 두 번째 자식인 li 요소를 클릭하면 클릭 이벤트가 발생한다.
이때 **생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소의 이벤트 타깃을 중심으로 DOM 트리를 통해 전파 된다.**

이벤트 전파는 이벤트 객체가 전파되는 방향에 따라 다음과 같이 3단계로 구분할 수 있다.

- 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계: 이벤트가 이벤트 타깃에 도달
- 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파

**이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치 할 수 있다.**

## **40.7 이벤트 위임**

만약 아이템이 100개라면 100개의 이벤트 핸들러를 등록해야 하는데
이 경우 성능 저하의 원인이 되며 유지보수에도 부적합하다.

이벤트 위임은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신
하나의 상위 DOM요소에 이벤트 핸들러를 등록하는 방법을 말한다.

## **40.8 DOM 요소의 기본 동작의 조작**

### **40.8.1 DOM 요소의 기본 동작 중단**

DOM요소는 저마다 기본 동작이 있다.

이벤트 객체의 preventDefault 메서드는 이러한 DOM요소의 기본 동작을 중단 시킨다.

### **40.8.2 이벤트 전파 방지**

이벤트 객체의 stopPropagation 메서드는 이벤트 전파를 중지 시킨다.

## **40.9 이벤트 핸들러 내부의 this**

### **40.9.1 이벤트 핸들러 어트리뷰트 방식**

이벤트 핸들러 어트리뷰트 방식에 의해 암묵적으로 생성된 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

이는 이벤트 핸들러 프로퍼티 방식과 동일하다.

### **40.9.2 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식**

두 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM요소를 가리킨다.

즉, 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다.

화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다.

화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다.

## **40.10 이벤트 핸들러에 인수 전달**

함수에 인수를 전달하려면 함수를 호출할때 전달해야 한다.

이벤트 핸들러 어트리뷰트 방식은 함수 호출문을 사용할 수 있기 때문에 인수 전달할 수 있다.

이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식의 경우 이벤트 핸들러를 브라우저가 호출하기 때문에 함수 호출문이 아닌 함수 자체를 등록해야 한다.
따라서 인수르 전달할 수 없다.

하지만 이벤트 핸들러 내부에서 함수를 호출면서 인수를 전달할 수 있다.

또는 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수도 있다

## **40.11 커스텀 이벤트**

### **40.11.1 커스텀 이벤트 생성**

암묵적으로 생성되는 이벤트 객체는 이벤트 종류에 따라 이벤트 타입이 결정된다.

하지만 Event, UIEvent, MouseEvent 같은 이벤트 생성자 함수를 호출하여 명시적으로 생성한 이벤트 객체는 임의의 이벤트 타입을 지정 할 수 있다 

이를 이벤트 커스텀 이벤트라 한다.

생성된 커스텀 이벤트 객체는 버블링되지 않으며 preventDefault 메서드로 취소할 수도 없다.

bubbles와 cancelable 프로퍼티뿐만 아니라 이벤트 타입에 따라 가지는 이벤트 고유의 프로퍼티 값을 지정할 수 있다.

이벤트 생성자 함수로 생성한 커스텀 이벤트는 isTrusted 프로퍼티의 값이 언제나 false다.

사용자의 행위에 의해 발생한 이벤트에 의해 생성된 이벤트 객체의 isTruste 프로퍼티 값은 언제나 true다

### **40.11.2 커스텀 이벤트 디스패치**

생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치(이벤트를 발생시키는 행위)할 수 있다.

이벤트 객체를 인수로 전달하면서 호출하면 인수로 전달한 이벤트 타입의 이벤트가 발생한다.

일반적으로 이벤트 핸들러는 비동기 처리 방식으로 동작하지만 dispatchEvent 메서드는 동기 처리 방식으로 호출한다.

기존 이벤트 타입이 아닌 임의의 이벤트 타입을 지정하여 이벤트 객체를 생성하는 경우 CustomEvent 이벤트 생성자 함수를 사용한다.

기존 이벤트 타입이 아닌 임의의 이벤트 타입을 지정하여 터스텀 이벤트 객체를 생성한 경우 반드시 addEventListener 메서드 방식으로 이벤트 핸들러를 등록해야 한다.

# **41장 타이머**

## **41.1 호출 스케줄링**

함수를 명시적으로 호출하지 않고 일정 시간이 경과된 이후에 호출되도록 예약하려면 타이머 함수를 사용한다.

이를 **호출 스케줄링**이라 한다.

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖기 때문에
두 가지 이상의 태스크를 동시에 실행할 수 없다.
즉, 자바스크립트 엔진은 **싱글 스레드**로 동작한다.
이런 이유로 타이머 함수 setTimeout과 setInterval은 **비동기 처리 방식**으로 동작 한다.

## **41.2 타이머 함수**

### **41.2.1 setTimeout / cleanTimeout**

setTimeout 함수의 콜백 함수는 두 번째 인수로 전달받은 시간 이후 단 한 번 실행되도록 호출 스케줄링된다.

```jsx
const timeoutId = setTimeout(func|code[, delay, param1, param2, ...])
```

| 매개변수 | 설명 |
| --- | --- |
| func | 타이머가 만료된 뒤 호출될 콜백 함수 |
| delay | 타이머 만료 시간 setTimeout 함수는 delay 시간으로 단 한 번 동작하는 타이머를 생성 한다.
인수 전달을 생략한 경우 기본값은 0 |
| param1, param2, …  | 호출 스케줄링된 콜백 함수에 전달해야 할 인수가 존재하는 경우 세 번째 히우의 인수로 전달할 수 있음 |

```jsx
// 1초(1000 ms) 후 타이머가 만료되면 콜백 함수가 호출 됨
setTimeout(() => console.log("hi"), 1000);

// 1초(1000 ms) 후 타이머가 만료되면 콜백 함수가 호출 됨
// 이때 콜백 함수에 'Lee'가 인수로 전달 됨
setTimeout((name) => console.log(`hi ${name}`), 1000, "Lee");

// 두 번째 인수(delay)를 생략하면 기본값 0이 지정됨
setTimeout((name) => console.log(`hello`));
```

cleanTimeout 함수는 호출 스케줄링을 취소 한다

```jsx
// 1초(1000 ms) 후 타이머가 만료되면 콜백 함수가 호출 됨
// setTimeout 함수는 생성된 타이머를 식별할 수 있는 고유한 타이머 id를 반환함
const timeoutId = setTimeout(() => console.log(`hi`), 1000);

// setTimeout 함수가 반환한 타이머 id를 cleanTimeout 함수의 인수로 전달하여 타이머를 취소 함
// 타이머가 취소되면 setTimeout 함수의 콜백 함수가 실행 되지 않음
cleanTimeout(timeoutId);
```

### **41.2.2 setInterval / cleanInterval**

setInterval 함수의 콜백 함수는 두 번째 인수로 전달받은 시간이 경과할 때마다 반복 실행되도록 호출 스케줄링된다.

## **41.3 디바운스와 스로틀**

scroll, resize, input mousemove, mouseover 같은 이벤트는 짧은 시간 간격으로 연속해서 발생한다.

이러한 이벤트 핸들러는 과도하게 호출되어 성능에 문제를 일으킬 수 있다.

디바운스와 스로틀은 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다.

### **41.3.1 디바운스**

이벤트 핸들러가 한 번만 호출되도록 하는 디바운스는 resize나 input 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성 UI구현, 버튼 중복 클릭 방지 처리 등에 유용하게 사용된다.

실무에서는 Underscore의 debounce 함수나 Lodash의 debounce 함수를 사용하는 것을 권장 한다.

### **41.3.2 스로틀**

짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출 되도록 한다.

즉, 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.

scroll 이벤트 처리나 무한 스크롤 UI 구현 등에 유용하게 사용된다

실무에서는 Underscore의 throttle 함수나 Lodash의 throttle 함수를 사용하는 것을 권장 함

# **42장 비동기 프로그래밍**

## 42.1 동기 처리와 비동기 처리

함수의 실행 순서는 실행 컨텍스트 스택으로 관리한다.

**자바스크립트 엔진은 단 하나의 실행 컨택스트 스택을 갖는다.**

동시에 2개 이상의 함수를 실행할 수 없다는 것을 의미한다.

실행 중인 컨텍스트를 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들이다.

대기중인 태스크들은 현재 실행 중인 함수가 종료하면 비로소 실행되기 시작한다.

이처럼 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드** 방식으로 동작한다.

처리에 시간이 걸리는 태스크를 실행하는 경우 **블로킹(작업 중단)**이 발생한다.

현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 **동기 처리**라고 한다.

이는 실행 순서가 보장된다는 장점이 있지만,
앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있다.

현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 **비동기 처리**라고 한다.

이는 현재 실행중인 태스크가 종료되지 않은 상태라해도 다음 태스크를 곧바로 실행하므로 블로킹이 발생하지 않는다는 장점이있지만,
태스크의 실행 순서가 보장되지 않는 단점이있다.

**타이머 함수인 setTimeout과 setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.**

비동기 처리는 이벤트 루프와 태스크 큐와 깊은 관계가 있다.

## **42.2 이벤트 루프와 태스크 큐**

자바스크립트의 동시성을 지원하는 것이 **이벤트 루프**다.

구글의 V8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.

- **콜 스택**
    
    생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 **콜 스택**이다.
    
    함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 수시되어 순차적으로 실행된다.
    
- **힙**
    
    객체가 저장되는 메모리 공간이다.
    
    콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
    

자바스크립트 엔진은 태스크 요청 시 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다.

비동기 처리에서 소스코드의 평과와 실행을 제외한 모든 처리는 브라우저 또는 Node.js가 담당한다.

이를 위해 브라우전 환경은 태스크 큐와 이벤트 루프를 제공한다.

- **태스크 큐**
    
    비동기 함수의 콜백함수, 이벤트 핸들러가 일시적으로 보관되는 영역이다.
    
- **이벤트 루프**
    
    콜 스택에 현재 실행 중인 실행 컨택스트가 있는지,
    태스크큐에 대기 중인 함수가 있는지 반복해서 확인한다.
    
    콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기중인 함수를 콜 스택으로 이동시킨다.
    

# **43장 - Ajax**

## 43.1 Ajax란

Ajax는 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식이다.

Ajax는 브라우저에서 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작한다.

Ajax는 전통적인 방식과 비교했을 때 다음과 같은 장점이 있다.

1. 변경할 부분만 전송받기 때문에 불필요한 통신이 발생하지 않는다.
2. 변경할 필요가 없는 부분은 다시 렌더링하지 않는다.
3. 클라이언트와 서버간의 통신이 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸이후 블로킹이 발생하지 않는다. 

## **43.2 JSON**

JSON은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다.

자바스크립트에 종속되지 않는 언어 독립형 데이터 포멧으로, 대부분의 프로그래밍 언어에서 사용할 수 있다.

### 43.2.1 JSON 표기 방식

JSON은 키와 값으로 구성된 순수한 텍스트다.

```json
{
  "name": "Lee",
  "age": 20,
  "alive": true,
  "hobby": ["traveling", "tennis"]
}
```

키는 반드시 큰따옴표로 묶어야 한다.
값은 객체 리터럴과 같은 표기법을 그대로 사용할 수 있다.

### **43.2.2 JSON.stringify**

객체를 JSON 포맷의 문자열로 변환한다.

서버로 객체를 전송하려면 객체를 문자열화해야 하는데 이를 직렬화라고 한다.

객체뿐만 아니라 배열도 JSON 포맷의 문자열로 변환한다.

### **43.2.3 JSON.parse**

JSON 포맷의 문자열을 객체로 변환한다.

서버로부터 전송받은 JSON 데이터는 문자열이다.

JSON 포멧의 문자열을 객체화해야 하는데 이를 역직렬화라 한다.

배열이 JSON 포맷의 문자열로 변환되어 있는 경우 배열 객체로 변환한다.

배열의 요소가 객체인 경우 배열의 요소까지 객체로 변환한다.

## **43.3 XMLHttpRequest**

자바스크립트를 사용하여 HTTP 요청을 전송하려면 XMLHttpRequest 객체를 사용해야 한다.

Web API인 XMLHttpRequest 객체는 HTTP 요청 전송과 응답 수신을 위한 다양한 메서드와 프로퍼티를 제공한다.

### 43.3.1 XMLHttpRequest 객체 생성

XMLHttpRequest 객체는 XMLHttpRequest 생성자 함수를 호출하여 생성한다.

브라우저 환경에서만 정상적으로 실행된다.

### 43.3.2 XMLHttpRequest 객체의 프로퍼티와 메서드

XMLHttpRequest 객체는 다양한 프로퍼티와 메서드를 제공한다.

### 43.3.3 HTTP 요청 전송

HTTP 요청을 전송하는 경우 다음 순서를 따른다.

1. XMLRequest.prototype.open 메서드로 HTTP 요청을 초기화한다.
2. 필요에 따라 XMLHttpRequest.prototype.setRequestHeader 메서드로 특정 HTTP 요청 헤더 값을 설정한다.
3. XMLHttpRequest.prototype.send 메서드로 HTTP 요청 전송한다.

### 43.3.4 HTTP 응답 처리

서버가 전송한 응답을 처리하려면 XMLHttpRequest 객체가 발생시키는 이벤트를 캐치해야한다.

XMLHttpRequest 객체는 onreadystatechange, onload, onerror 같은 이벤트 핸들러를 갖는다.

HTTP 요청의 현재 상태를 나타내는 readyState 프로퍼티 값이 변경된 경우 발생하는 readystatechange 이벤트를 캐치하여 HTTP 응답을 처리할 수 있다.
