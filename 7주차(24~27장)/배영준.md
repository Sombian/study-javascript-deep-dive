# 24장\_클로저

**클로저란?**

> 클로저는 **함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.**

클로저는 자바스크립트 고유의 개념이 아니다!

## 렉시컬 스코프(정적 스코프)

자바스크립트 엔진은 **함수를 어디서 호출했는지가 아닌, 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.**

**함수의 상위 스코프를 결정**한다는 것은 **렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다는 것**과 같다.

위의 외부 렉시컬 환경에 대한 참조에 저장할 참조값이 바로 상위 렉시컬 환경에 대한 참조이고, 즉 상위 스코프이다.

즉, 렉시컬 스코프의 정의는

렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 **상위 스코프에 대한 참조**는 **함수 정의가 평가되는 시점에 함수가 정의된 환경**에 의해 결정된다.

## 함수 객체의 내부 슬롯 [[Environment]]

함수는 자신이 내부 슬롯 `[[Environment]]`에 자신이 정의된 환경, 상위 스코프의 참조를 저장한다.

함수 객체의 내부 슬롯 `[[Environment]]`에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다.

또한, 자신이 호출되었을 때 생성한 함수 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다.

함수 객체는 내부 슬롯 `[[Environment]]` 에 저장된 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.

```jsx
const x = 1;

function foo() {
  const x = 10;

  // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다.
  bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 [[Environment]]에 저장하여 기억한다.
function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 `[[Environment]]` 에 저장된 렉시컬 환경의 참조가 할당된다.

⇒ 함수의 상위 스코프를 의미한다.

## 클로저와 렉시컬 환경

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

외부함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 다시 참조할 수 있다. 이러한 중첩 함수를 **클로저**라고 한다.

이론적으로, 자바스크립트의 모든 함수는 상위 스코프를 기억하기에 전부 클로저이다.

하지만 일반적으로 모든 함수를 클로저라고 부르진 않는다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 일반적으로 클로저라고 하지 않는다.
      function bar() {
        const z = 3;

        debugger;
        // 상위 스코프의 식별자를 참조하지 않는다.
        console.log(z);
      }

      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 외부 함수 foo보다 더 오래 유지되지만(클로저의 정의에 부합함), 상위 스코프의 어떤 식별자도 참조하지 않는다.

이론적으로 클로저가 될 수 있지만 상위 스코프를 기억하지 않기에(메모리 절약) 클로저라고 할 수 없다.

결론적으로, 다시 클로저에 대해 구분하자면

**중첩 함수가 상위 스코프의 식별자를 참조하고 있고, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.**

## 클로저의 활용

상태를 안전하게 변경하고, 유지하기 위해 사용된다.

⇒ 상태를 안전하게 은닉(의도치 않게 변경되지 않도록)하고, 특정 함수에게만 상태 변경을 허용하기 위해 사용된다.

## 캡슐화와 정보 은닉

**캡슐화**

객체의 상태를 나타내는 프로퍼티와, 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.

**정보 은닉**

캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라고 한다.

외부에 공개할 필요가 없는 구현의 일부를 감추어, 정보를 보호하고, 객체간의 상호 의존성(결합도)를 낮추는 효과가 있다.

자바스크립트는 정보 은닉을 완전하게 지원하지 않지만, 클래스에 private 필드를 정의할 수 있는 새로운 표준 사양으로 정보 은닉이 가능하다.

## 자주 발생하는 실수

var 키워드가 아닌 let 키워드, const 키워드를 사용하자.

let, const를 사용하는 반복문은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성, 반복할 당시의 상태를 하나하나 저장한다.

→ 반복문이 코드 내부에서 함수를 정의할 때 의미가 있다.

# 25장\_클래스

## 클래스는 프로토타입의 문법적 설탕인가?

~~이게 무슨 소리지~~

자바스크립트는 프로토타입 기반의 객체지향 언어이다.

프로토타입 객체지향 언어는 클래스가 필요 없는 객체지향 프로그래밍 언어이다.

생성자 함수, 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있지만(클래스 없어도), 클래스 기반에 익숙한 사람들에겐 하나의 장벽으로 인식되었다.

ES6에 도입된 클래스는 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 객체 생성 메커니즘을 지향한다.

하지만 새롭게 클래스 기반 객체지향 모델을 제공하는 건 아니다. 클래스로 보이지만 사실 함수이며, 기존 프로토타입 기반 패턴을 클래스 기반으로 사용할 수 있게 하는 문법적 설탕…이라고 볼 수도 있다.

하지만, 새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다.

클래스는 생성자 함수와 매우 유사하게 동작하지만, 차이점이 존재한다.

1. 클래스를 `new`연산자 없이 호출하면 에러가 발생한다.(생성자 함수를 `new`연산자 없이 호출하면 일반 함수로 호출된다.)
2. 클래스는 상속을 지원하는 `extends`와 `super`키워드를 제공한다.(생성자 함수는 지원하지 않는다.)
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.(함수 선언문은 함수 호이스팅, 함수 표현식은 변수 호이스팅이 발생한다.)
4. 클래스 내의 모든 코드에는 암묵적으로 `strict mode`가 지정되어 실행되며 해제할 수 없다.(생성자 함수는 지정되지 않는다.)
5. 클래스의 `constructor`, 프로토타입 메서드, 정적 메서드는 열거되지 않는다.(모두 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 `false`다.)

## 클래스 정의

```jsx
class Person {}

// 익명 클래스 표현식
const Person = class {};

// 가명 클래스 표현식
const Person = class MyClass {};
```

클래스는 값으로 사용할 수 있는 일급 객체이다. = 함수이다.

- 무명의 리터럴로 생성할 수 있다.(즉, 런타임에 생성이 가능하다.)
- 변수나 자료구조(객체, 배열등)에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

클래스 몸체에서 정의할 수 있는 메서드는 `constructor`, **프로토타입 메서드**, **정적 메서드** 세 가지가 있다.

```jsx
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log("Hello!");
  }
}

// 인스턴스 생성
const me = new Person("Lee");

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

## 클래스 호이스팅

클래스는 함수로 평가된다.

클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다.

하지만 let, const로 선언한 변수처럼 호이스팅된다.

## 인스턴스 생성

클래스는 생성자 함수이며, new 연산자와 함께 호출되어 인스턴스를 생성한다.

## 메서드

클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다.

클래스 몸체에서 정의할 수 있는 메서드는 `constructor`, **프로토타입 메서드**, **정적 메서드** 세 가지가 있다.

### constructor

인스턴스를 생성하고, 초기화하기 위한 특수한 메서드이다. 이름을 변경할 수 없다.

생략이 가능하고, 별도의 반환문을 가지지 않아야 한다. 암묵적으로 this를 반환하기 때문이다.

### 프로토타입 메서드

생성자 함수를 사용하여 인스턴스 생성 시, 프로토타입 메서드를 생성하기 위해서는 명시적으로 프로토타입에 메서드를 추가해야 한다.

클래스 몸체에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다.

⇒ 클래스는 생성자 함수와 같이, 인스턴스를 생성하는 생성자 함수라고 볼 수 있다.

클래스는 프로토타입 기반의 객체 생성 메커니즘이다.

```jsx
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person("Lee");
me.sayHi(); // Hi! My name is Lee
```

### 정적 메서드

인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다.

클래스에서는 메서드에 static을 붙이면 정적 메서드(클래스 메서드)가 된다.

정적 메서드는 클래스 정의 이후 인스턴스를 생성하지 않아도 호출이 가능하다.

인스턴스로 호출하지 않고, 클래스로 호출한다.

```jsx
// 정적 메서드는 클래스로 호출한다.
// 정적 메서드는 인스턴스 없이도 호출할 수 있다.
Person.sayHi(); // Hi!
```

### 정적 메서드, 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

메서드 내부의 this는 메서드를 호출한 객체에 바인딩하게 되는데, 정적 메서드는 클래스로 호출해야 하기 때문에 정적 메서드 내부의 this는 클래스를 가리킨다. 프로토타입 메서드는 인스턴스로 호출하므로, this는 프로토타입 메서드를 호출한 인스턴스를 가리킨다.

### 클래스에서 정의한 메서드의 특징

- `function`키워드를 생략한 메서드 축약 표현을 사용한다.
- 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
- 암묵적으로 `strict mode`로 실행된다.
- `for...in`문이나 `Object.keys`메서드 등으로 열거할 수 없다.(`[[Enumerable]]`값이 `false`다.)
- 내부 메서드 `[[Construct]]`를 갖지 않는 `non-constructor`다.(`new`연산자와 함께 호출할 수 없다.)

## 클래스의 인스턴스 생성 과정

클래스는 new 연산자 없이 호출이 불가능하다.

1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환

## 프로퍼티

### 인스턴스 프로퍼티

constructor 내부에서 정의해야 한다.

인스턴스 프로퍼티는 언제나 public하다. (ES6의 클래스는 접근 제한자를 지원하지 않는다)

### 접근자 프로퍼티

자체적으로 값을 가지지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장하는데 사용하는 접근자 함수(getter, setter)로 구성된 프로퍼티이다.

### 클래스 필드 정의 제안

클래스 필드는, 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어이다.

자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있다.

클래스 몸체에서 필드를 정의할 경우, this에 클래스 필드를 바인딩해서는 안 된다.

클래스 필드를 참조할 경우, 자바스크립트에서는 this를 반드시 사용해야 한다.

클래스 필드에 초기값을 할당하지 않을 시 undefined를 가진다.

인스턴스를 생성할 때, 외부의 초기값으로 클래스 필드를 초기화해야 할 필요가 있다면 constructor에서 클래스 필드를 초기화해야 한다.

함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있다. 따라서 클래스 필드를 통해 메서드를 정의할 수도 있다. 이 경우 함수는 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.

모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문이다. 따라서 클래스 필드에 함수를 할당하는 것은 권장하지 않는다.

### private 필드 정의 제안

```jsx
class Person {
  // private 필드 정의
  #name = "";

  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}

const me = new Person("Lee");

// private 필드 #name은 클래스 외부에서 참조할 수 없다.
console.log(me.#name);
// SyntaxError: Private field '#name' must be declared in an enclosing class
```

private는 클래스 내부에서만 참조가 가능하고, 자식 클래스 내부에서는 참조가 불가능하다.

인스턴스를 통한 접근도 불가능하다.

반드시 클래스 몸체에 정의하자.

### static 필드 정의 제안

```jsx
class MyMath {
  // static public 필드 정의
  static PI = 22 / 7;

  // static private 필드 정의
  static #num = 10;

  // static 메서드
  static increment() {
    return ++MyMath.#num;
  }
}

console.log(MyMath.PI); // 3.142857142857143
console.log(MyMath.increment()); // 11
```

## 상속에 의한 클래스 확장

### 클래스 상속과 생성자 함수 상속

상속에 대한 클래스 확장은 기존 클래스를 상속받아, 새로운 클래스를 확장하며 정의하는 것이다.

### extends 키워드

상속을 통해 클래스를 확장하려면, extends 키워드를 사용하여 상속받을 클래스를 정의한다.

상속을 통해 확장된 클래스를 서브 클래스라고 부른다.

서브 클래스에게 상속된 클래스를 수퍼클래스라고 부른다.

### 동적 상속

extends는 클래스 뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수도 있다.

extends 키워드 앞에는 반드시 클래스가 와야 한다.

### 서브클래스의 constructor

생략 시 빈 객체가 생성된다.

프로퍼티를 소유하는 인스턴스를 생성하려면, constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다.

### super 키워드

함수처럼 호출할 수 있고, this와 같이 식별자처럼 참조할 수 있는 특수한 키워드이다.

**super 호출**

수퍼클래스의 constructor를 호출한다.

서브 클래스에서 constructor를 사용하려면 반드시 super를 호출해야 한다.

서브 클래스의 constructor에서 super를 호출하기 이전에는 this를 참조할 수 없다.

super는 반드시 서브 클래스의 constructor에서만 호출한다.

**super 참조**

메서드 내에서 super를 참조하면, 수퍼클래스의 메서드를 호출할 수 있다.

### 상속 클래스의 인스턴스 생성 과정

```jsx
// 수퍼클래스
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }

  toString() {
    return `width = ${this.width}, height = ${this.height}`;
  }
}

// 서브클래스
class ColorRectangle extends Rectangle {
  constructor(width, height, color) {
    super(width, height);
    this.color = color;
  }

  // 메서드 오버라이딩
  toString() {
    return super.toString() + `, color = ${this.color}`;
  }
}

const colorRectangle = new ColorRectangle(2, 4, "red");
console.log(colorRectangle); // ColorRectangle {width: 2, height: 4, color: "red"}

// 상속을 통해 getArea 메서드를 호출
console.log(colorRectangle.getArea()); // 8
// 오버라이딩된 toString 메서드를 호출
console.log(colorRectangle.toString()); // width = 2, height = 4, color = red
```

1. 서브클래스의 super 호출
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 constuctor로의 복귀, this 바인딩
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환

### 표준 빌트인 생성자 함수 확장

표준 빌트인 객체도 [[Construct]] 내부 메서드를 갖는 생성자 함수이므로, extends 키워드를 사용해 확장이 가능하다.

# 26장\_ES6 함수의 추가 기능

## 함수의 구분

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론, 생성자 함수로서 호출할 수 있다.

⇒ callable이며, constructor이다.

ES6에서는 함수를 사용 목적에 따라 3가지 종류로 구분한다.

| ES6 함수의 구분 | constructor | prototype | super | arguments |
| --------------- | ----------- | --------- | ----- | --------- |
| 일반함수        | o           | o         | x     | o         |
| 메서드          | x           | x         | o     | o         |
| 화살표 함수     | x           | x         | x     | x         |

일반함수는 ES6 이전의 함수와 차이가 없다. 하지만 메서드와 화살표 함수는 ES6이전의 함수와 명확한 차이가 있다. 일반 함수는 constructor 이지만 ES6의 메서드와 화살표 함수는 non-constructor이다.

## 메서드

메서드 축약 표현으로 정의된 함수만을 의미한다.

ES6 메서드는 인스턴스를 생성할 수 없는 non-constructor이다.

생성자 함수로서 호출할 수 없고, 프로토타입 프로퍼티도 없고 생성도 안 한다.

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.

super 참조는 이 내부 슬롯을 사용하여 수퍼 클래스의 메소드를 참조한다. 따라서 이 내부 슬롯을 갖는 ES6 메서드는 super 키워드를 사용할 수 있다.

## 화살표 함수

function 키워드 대신 화살표를 사용하여 간략하게 함수를 정의할 수 있다.

콜백 함수 내부에서 this가 전역 객체를 가라키는 문제를 해결하기 위한 대안으로 유용하다.

### 화살표 함수 정의

함수 선언문으로 정의할 수 없고, 함수 표현식으로 정의해야 한다.

### 일반 함수와의 차이

인스턴스를 생성할 수 없다.

중복된 매개변수 이름을 선언할 수 없다.

함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않기 때문이다.(스코프를 통해 상위 스코프의 this …을 참조한다.

### this

화살표 함수는 함수 자체의 this 바인딩을 갖지 않기에, 상위 스코프의 this를 그대로 참조한다.

### super

상위 스코프의 super를 참조한다.

### arguments

상위 스코프의 arguments를 참조한다.

## Rest 파라미터

Rest 파라미터는 함수에 전달된 인수의 목록을 배열로 전달받는다.

일반 매개변수와 함께 사용할 수 있으며, 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당되므로 반드시 마지막 파라미터야 한다.

### Rest 파라미터와 arguments 객체

arguments는 배열이 아닌 유사 배열 객체이므로, 배열 메서드 사용에 어려움이 있다.

rest 파라미터를 사용해 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다.

화살표 함수로 가변 인자 함수를 구현할 때는 반드시 rest 파라미터를 사용해야 한다.

## 매개변수 기본값

인수가 전달되지 않은 매개변수의 값은 undefined이다.

매개변수 기본값을 사용 시, 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.

# 27장\_배열

## 배열이란?

여러 개의 값을 순차적으로 나열한 자료구조이다.

일반 객체와 배열을 구분하는 명확한 차이는, 값의 순서와 length 프로퍼티이다.

## 자바스크립트 배열은 배열이 아니다.

**밀집 배열:** 배열의 요소가 하나의 데이터 타입으로 통일되어 있고 연속적으로 인접해 있는 것.

**희소 배열**: 배열 요소 각각의 메모리 공간은 서로 다를 수 있고 연속적이지 않을 수 있다.

자바스크립트의 배열은, 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.

자바스크립트 배열은, 인덱스로 배열 요소에 접근하는 경우는 일반 배열보다 느리다.

하지만 요소 삽입, 삭제같은 경우에는 일반 배열보다 빠르다.

## length 프로퍼티와 희소 배열

일반 배열의 경우 length는 배열 요소의 개수, 길이와 언제나 일치한다.

하지만 희소 배열의 경우, length와 배열 요소의 개수가 일치하지 않는다.

희소 배열의 length는 언제나 실제 요소 개수보다 크다.

## 배열 생성

### 배열 리터럴

```jsx
const arr = [1, 2, 3];

//희소 배열
const arr1 = [1, , 3];
```

### Array 생성자 함수

```jsx
const arr = new Array(10);
// 실제로 배열의 요소는 존재하지 않으므로 희소 배열임.
```

### Array.of

```jsx
Array.of(1); // -> [1]
```

### Array.from

유사 배열 객체, 이터리블 객체를 인수로 전달받아 배열로 반환하여 반환한다.

```jsx
Array.from({ length: 2, 0: "a", 1: "b" }); // ['a', 'b']

Array.from("Hello"); // ['H', 'e', ... , 'o']
```

## 배열 요소의 참조

배열 요소를 참조할 때에는 대괄호 표기법을 사용한다.

대괄호 안에는 인덱스가 와야 한다.

## 배열 요소의 추가와 갱신

요소를 동적으로 추가할 수 있다.

## 배열 요소의 삭제

delete 연산자를 사용해 삭제가 가능하다.

delete는 희소 배열을 만들 가능성이 높으므로, 배열의 특정 요소를 완전히 삭제하려면 Array.prototype.splice 메서드를 사용하다.

## 베열 메서드

배열에는 원본 배열을 직접 변경하는 메서드와, 새로운 배열을 생성하여 반환하는 메서드가 있다.

## 배열 고차 함수

고차 함수는 외부 상태의 변경, 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.
