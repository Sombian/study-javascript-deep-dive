# [11회차 06.09.] 44, 45, 46, 47, 48장

# **44장 REST API**

**REST** 는 HTTP 를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고,
**REST API** 는 REST 를 기반으로 서비스 API 를 구현한 것을 의미한다.

## **44.1 REST API 의 구성**

REST API 는 자원, 행위, 표현의 3가지 요소로 구성된다.

REST 는 자체 표현 구조로 구성되어 REST API 만으로 HTTP 요청의 내용을 이해할 수 있다.

| 구성 요소 | 내용 | 표현 방법 |
| --- | --- | --- |
| 자원 (resource) | 자원 | URI (엔드포인트) |
| 행위 (verb) | 자원에 대한 행위 | HTTP 요청 메서드 |
| 표현 (representations) | 자원에 대한 행위의 구체적 내용 | 페이로드 |

## **44.2 REST API 설계 원칙**

**REST 에서 가장 중요한 기본적인 원칙 두 가지**

- **URI 는 리소스를 표현하는 데 집중**
- **행위에 대한 정의는 HTTP 요청 메서드**를 통해 하는 것
1. URI 는 리소스를 표현해야 한다.
    - URI 는 리소스를 표현하는 데 중점을 두어야 한다.
    - 리소스를 식별할 수 있는 이름은 동사보다는 명사를 사용한다.
    
    ```jsx
    # bad
    GET /getTodos/1
    GET /todos/show/1
    
    # good
    GET /todos/1
    ```
    
2. 리소스에 대한 행위는 HTTP 요청 메서드로 표현한다.
    
    **클라이언트가 서버에게 요청의 종류와 목적을 알리는 방법**
    
    | HTTP 요청 메서드 | 종류 | 목적 | 페이로드 |
    | --- | --- | --- | --- |
    | GET | index/retrieve | 모든/특정 리소스 취득 | X |
    | POST | create | 리소스 생성 | O |
    | PUT | replace | 리소스의 전체 교체 | O |
    | PATCH | modify | 리소스의 일부 수정 | O |
    | DELETE | delete | 모든/특정 리소스 삭제 | X |
    
    리소스에 대한 행위는 URI 에 표현하지 않고, 요청 메서드로 리소스에 대한 행위를 명확히 표현한다.
    

## **44.3 JSON Server 를 이용한 REST API 실습**

### **44.3.4 GET 요청**

todos 리소스에서 모든 todo 를 취득 (index) 하거나 id 를 사용하여 특정 todo 를 취득 (retrieve) 할 수 있다.

### **44.3.5 POST 요청**

POST 요청 시에는 setRequestHeader 메서드를 사용하여 요청 바디에 담아 서버로 전송할 페이로드의 MIME 타입을 지정해야 한다.

### **44.3.6 PUT 요청**

PUT 은 특정 리소스 전체를 교체할 때 사용한다.

todo 를 특정하여 id 를 제외한 리소스 전체를 교체하고, setRequestHeader 메서드를 사용하여 요청 바디에 담아 서버로 전송할 페이로드의 MIME 타입을 지정해야 한다.

### **44.3.7 PATCH 요청**

PATCH 는 특정 리소스의 일부를 수정할 때 사용한다.

setRequestHeader 메서드를 사용하여 요청 바디에 담아 서버로 전송할 페이로드의 MIME 타입을 지정해야 한다.

### **44.3.8 DELETE 요청**

todos 리소스에서 id 를 사용하여 todo 를 삭제한다.

# **45장 프로미스**

ES6에서 비동기 처리를 위한 패턴으로 프로미스를 도입했다.

전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

## **45.1 비동기 처리를 위한 콜백 패턴의 단점**

### **45.1.1 콜백 헬**

비동기 함수 내부의 비동기로 동작하는 코드는 밉동기 함수가 종료된 이후에 완료된다.

따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.

비동기 함수는 비동기 처리 결과를 외부에 반활할 수 업고, 상위 스코프의 변수에 할당할 수동 없다.

따라서 비동기 함수의 처리 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.

콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상이 발생한다.
이를 **콜백 헬**이라고 한다.

```jsx
get('/step1', a => {
	get(`/step2/${a}`, b => {
		get(`/step3/${b}`, c => {
			get(`/step4/${c}`, d => {
				console.log(d);
			});
		});
	});
});
```

### **45.1.2 에러 처리의 한계**

비동기 처리를 위한 콜백 패턴의 문제점 중에서 가장 심각한 것은 에러 처리가 곤란하다는 것이다.

```jsx
try {
	setTimeout(() => { throw new Error('Error!'); }, 1000);
} catch(e){
	//에러를 캐치하지 못한다.
	console.log('캐치한 에러', e);
}
```

비동기 처리를 위한 콜백 패턴은 **콜백 헬**과 **에러 처리가 곤란하다는 문제**가 있다.
이를 해결하기 위해 ES6에서 프로미스가 도입됐다.

## **45.2 프로미스의 생성**

Promise 생성자 함수를 new와 함께 호출하면 프로미스를 생성한다. Promise는 표준 빌트인 객체다.
Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달 받는데
이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.

```jsx
const promise = new Promise((resolve, reject) => {
  // Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행한다.
	if( /* 비동기 처리 성공 */ ){
		resolve('result');
	} else { /* 비동기 처리 실패 */
		reject('failure reason');
	}
});
```

비동기 함수 get을 프로미스를 사용해 다시 구현해보자.

```jsx
const promiseGet = (url) => {
	return new Promise((resolve, reject) => {
		const xhr = XMLHttpRequest();
		xhr.open('GET', url);
		xhr.send();

		xhr.onload = () => {
			// 성공적으로 응답을 전달받으면 resolve 함수를 호출한다.
			if(xhr.status === 200) {
				successCallback(JSON.parse(xhr.response));
			}else {
				// 에러 처리를 위해 reject 함수를 호출한다.
				failureCallback(xhr.status);
			}
		};
	});
};

// 프로미스를 반환한다.
promiseGet ('https://jsonplaceholder.typicode.com/posts/1');
```

프로미스는 다음과 같이 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 정보를 갖는다.

| 프로미스 상태 정보 | 의미 | 상태 변경 조건 |
| --- | --- | --- |
| pending | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
| fulfilled | 비동기 처리가 수행된 상태(성공) | resolve 함수 호출 |
| rejected | 비동기 처리가 수행된 상태(실패) | reject 함수 호출 |

생성된 직후의 프로미스는 기본적으로 pending 상태다.
이후 비동기 처리가 수행되면 비동기 처리 결과에 따라 다음과 같이 프로미스 상태가 변경된다.

- 비동기 처리 성공: resolve 함수를 호출해 프로미스를 fulfilled 상태로 변경.
- 비동기 처리 실패: reject 함수를 호출해 프로미스를 rejected 상태로 변경.

비동기 처리가 성공하면 프로미스는 pending 상태에서 fulfilled 상태로 변화한다.
그리고 비동기 처리 결과인 1을 값으로 갖는다.

비동기 처리가 실패하면 프로미스는 pending 상태에서 rejected 상태로 변화한다.
그리고 비동기 처리 결과인 Error객체를 값으로 갖는다.

**즉, 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.**

## **45.3 프로미스의 후속 처리 메서드**

프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.

### **45.3.1 Promise.prototype.then**

then은 두 개의 콜백 함수를 인수로 받는다.

- 첫 번째 콜백함수는 프로미스가 fulfilled 상태가 되면 호출된다. 이때 콜백 함수는 프로미스의 비동기 처리 결과를 인수로 전달받는다.
- 두 번째 콜백함수는 프로미스가 rejected 상태가 되면 호출된다. 이때 콜백 함수는 프로미스의 비동기 처리 결과를 인수로 전달받는다.

```jsx
new Promise(resolve => resolve('fulfilled'));
	.then(v => console.log(v), e => console.error(e)); 

new Promise(resolve => resolve('rejected'));
	.then(v => console.log(v), e => console.error(e));
```

### **45.3.2 Promise.prototype.catch**

catch 메서드는 한 개의 콜백 함수를 인수로 전달받는다.

catch 메서드의 콜백 함수는 프로미스가 **rejected** 상태인 경우에만 호출된다.

catch는 then과 동일하게 동작한다.

언제나 프로미스를 반환한다.

### **45.3.3 Promise.prototype.finally**

finally 메서드는 한 개의 콜백 함수를 인수로 전달받는다.

fulfilled와 rejected에 상관 없이 무조건 한 번은 호출된다.
프로미스 상태와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.

언제나 프로미스를 반환한다.

## **45.4 프로미스의 에러 처리**

비동기 처리에서 발생한 에러는 then 메서드의 두 번째 콜백 함수로 처리할 수 있다.

비동기 처리에서 발생한 에러는 프로미스의 후속 처리 메서드 catch를 사용해 처리할 수도 있다.

then 메서드의 두 번째 콜백 함수는 첫번째 콜백함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져서 가독성이 좋지 않다.

catch 메서드를 모든 then 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러 뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.

then 메서드에 두 번째 콜백 함수를 전달하는 것보다 catch 메서드를 사용하는 것이 가독성이 좋고 명확하다.
따라서 에러처리는 catch 메서드에서 하는 것을 권장한다.

## **45.5 프로미스 체이닝**

then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 사용할 수 있다.
이를 **프로미스 체이닝** 이라 한다.

프로미스는 프로미스 체이닝을 통해 후속 처리를 하므로 콜백 헬이 발생하지 않는다.
다만 프로미스도 콜백 패턴을 사용하므로 콜백 함수를 사용하지 않는 것은 아니다.

**콜백 패턴은 가독성이 좋지 않다.** 이 문제는 ES8에서 도입된 **async/await**를 통해 해결할 수 있다. 

## **45.6 프로미스의 정적 메서드**

promise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가질 수 있다.

Promise는 5가지 정적 메서드를 제공한다.

### **45.6.1 Promise.resolve / Promise.reject**

이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.

### **45.6.2 Promise.all**

여러 개의 비동기 처리를 모두 병렬로 처리할 때 사용한다.

### **45.6.3 Promise.race**

모든 프로미스가 fulfilled 상태가 되길 기다리는 것이 아니라 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve 하는 새로운 프로미스를 반환한다.

프로미스가 하나라도 rejected 상태가되면 에러를 reject하는 새로운 프로미스를 즉시 반환한다.

### **45.6.4 Promise.allSettled**

이터러블을 인수로 전달받는다.

전달 받은 프로미스가 모두 settled 상태가 되면 처리 결과를 배열로 반환한다.

반환한 배열에는 fulfilled 또는 rejected 상태와는 상관없이 전달 받은 모든 프로미스들의 결과가 모두 담겨 있다.

## **45.7 마이크로태스크 큐**

프로미스의 후속 처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로 태스크 큐에 저장된다.

마이크로 테스크 큐는 태스크 큐보다 우선순위가 높다.

## **45.8 fetch**

fetch함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 지원하는 클라이언트 사이드 Web API이다.

XMLHttpRequest보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다.

fetch 함수는HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.

fetch 함수가 반환하는 프로미스는 기본적으로 404, 500와 같은 HTTP 에러가 발생하도 에러를 reject하지 않고 불리언 타입의 ok 상태를 false로 설정한 Response 객체를 resolve한다.

네트워크 장애나 CORS 에러에 의해 요청이 완료되지 못한 경우에만 프로미스를 reject한다.

# **46장 제너레이터와 async/await**

## **46.1 제네레이터란?**

제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

제너레이터와 일반 함수의 차이는 다음과 같다.

1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권 양도할 수 있다.
2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
3. 제너레이터 함수를 호출하면 제너레이터 객체 반환한다.

## **46.2 제네레이터 함수의 정의**

function* 키워드로 선언한다. 그리고 하나 이상의 yield 표현식 포함한다.

애스터리스크(*) 위치는 function 키워드와 함수 이름 사이면 어디든지 상관없다.
일관성 유지를 위해 function 키워드 바로 뒤에 붙이는 것을 권장한다.

화살표 함수로 정의할 수 없다.

new 연산자와 함께 생성자 함수로 호출할 수 없다.

## **46.3 제네레이터 객체**

제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다.

제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터이다.

제너레이터 객체는 next 메서드를 갖는 이터레이터이지만, 이터레이터에 없는 return, throw 메서드를 갖는다.

## **46.4 제네레이터의 일시 중지와 재개**

yield 키워드와 next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개 가능

일반 함수는 호출 이후 제어권을 함수가 독점하나, 제너레이터는 함수 호출자에게 제어권을 양도하여 필요한 시점에 함수 실행 재개 가능

모든 코드를 일괄 실행하지 않고, yield 표현식까지만 실행한다.

yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가결과를 제너레이터 함수 호출자에게 반환한다.

## **46.5 제네레이터의 활용**

### **46.5.1 이터러블의 구현**

제네레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간단히 이터러블을 구현할 수 있다.

```jsx
// 무한 이터러블을 생성하는 제너레이터 함수
const infiniteFibonacci = (function* () {
	let [pre, cur] = [0, 1];
 
	while (true) {
		[pre, cur] = [cur, pre + cur];
		yield cur;
	}
}());

// infiniteFibonacci는 무한 이터러블
for (const num of infiniteFibonacci) {
	if (num > 10000) break;
	console.log(num); // 1 2 3 5 8... 2584 4181 6765
}
```

### **46.5.2 비동기 처리**

제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고받을 수 있다.
이러한 특성을 활요하면 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현할 수 있다.

## **46.6 async/await**

ES8에서 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 async/await가 도입되었다.

async/await는 프로미스를 기반으로 동작한다.

프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.

```jsx
const fetch = require('node-fetch');
 
async function fetchTodo() {
	const url = 'https://jsonplaceholder.typicode.com/todos/1';

	const response = await fetch(url);
	const todo = await response.json();
	console.log(todo);
	// {userid: 1, id: 1, title: 'delectus aut autem', completed: false}
}

fetchTodo();
```

### **46.6.1 async 함수**

await 키워드는 반드시 async 함수 내부에서 사용해야 한다.

async 함수는 async 키워드를 사용해 정의하며 언제나 프로미스를 반환한다.

async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환한다.

### **46.6.2 await 키워드**

await 키워드는 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과 반환한다.

await 키워드는 반드시 프로미스 앞에서 사용해야 한다.

### **46.6.3 에러 처리**

try... catch 문을 사용할 수 있다.

프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.

async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스 반환한다.

# **47장 에러 처리**

## **47.1 에러 처리의 필요성**

```jsx
console.log('[Start]');
foo(); // ReferenceError
 
console.log('[End]'); // 에러로 인해 해당 코드 실행 안됨
```

try ... catch 문을 사용해 발생한 에러에 적절하게 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드 실행시킬 수 있다.

```jsx
console.log('[Start]');
 
try {
  foo();
} catch (error) {
  console.error('[에러 발생]', error); // [에러 발생] ReferenceError
}

console.log('[End]');
```

## **47.2 try ... catch .. finally 문**

try ... catch ... finally 문을 실행하면 먼저 try 코드 블록 실행한다.

```jsx
try {
	// 실행할 코드 
} catch (err) {
  // try 코드 블록에서 에러가 발생하면 이 코드 블록의 코드가 실행
} finally {
  // 에러 발생과 상관없이 반드시 한 번 실행
}
```

## **47.3 Error 객체**

Error 생성자 함수에는 에러를 상세히 설명하는 에러 메시지를 인수로 전달할 수 있다.

```jsx
const error = new Error('invalid'); 
```

Error 생성자 함수가 생성한 에러 객체의 프로토타입은 모두 Error.prototype을 상속 받는다.

Error 생성자 함수를 포함해 7가지의 에러 객체 생성한다.

- `Error`: 일반적 에러 객체
- `SyntaxError`: 자바스크립트 문법에 맞지 않는 문을 해석할 때 발생
- `ReferenceError`: 참조할 수 없는 식별자를 참조했을 때 발생
- `TypeError`: 피연산자 또는 인수의 데이터 타입이 유효하지 않을 때 발생
- `RangeError`: 숫자 값의 허용 범위를 벗어났을 때 발생
- `URIError`: encodeURI 또는 decodeURI 함수에 부적절한 인수를 전달했을 때 발생
- `EvalError`: eval 함수에서 발생하는 에러 객체

```jsx
1 @ 1; // SyntaxError 
foo(); // ReferenceError
null.foo; // TypeError
new Array(-1); // RangeError
decodeURIComponent('%'); // URIError
```

## **47.4 throw 문**

Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다.
즉, 에러 객체 생성과 에러 발생은 의미가 다르다.

에러를 발생시키려면 try 코드 블록에서 throw 문으로 에러 객체를 던져야 함

```jsx
try {
  // 에러 객체를 던지면 catch 코드 블록 실행 시작
  throw new Error('something wrong');
} catch (error) { 
  console.log(error);
}
```

## **47.5 에러의 전파**

에러는 호출자 방향으로 전파된다.
즉, 콜 스택의 아래 방향으로 전파된다.

# **48장 모듈**

## **48.1 모듈의 일반적 의미**

모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.

일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다.

이때 모듈이 성립하려면 자신만의 **파일 스코프(모듈 스코프)**를 가질 수 있어야 한다.

모듈의 자산은 기본적으로 비공개 상태다.
즉, 모듈은 개별적 존재로서 애플리케이션과 분리되어 존재한다.

모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 의미가 있다.
따라서 **모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개 가능하다. 
이를 export라 한다.**

**모듈 사용자는 모듈이 공개한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용할 수 있다.
이를 import라 한다.**

## **48.2 자바스크립트와 모듈**

## **48.3 ES6 모듈(ESM)**

ES6에서 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가했다.

자바스크립트 파일이 아닌 ESM임을 명확하기 위해 ESM의 파일 확장자는 mjs를 사용할 것을 권장한단.

```jsx
<script type="module" src="app.mjs"></script> 
```

### **48.3.1 모듈스코프**

ESM은 독자적인 모듈 스코프를 갖는다.

ESM이 아닌 일반적인 자바스크립트 파일은 script 태그로 분리해서 로드해도 독자적인 모듈 스코프를 갖지 않는다.

모듈 내에서 var 키워드로 선언한 변수는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

모듈 내에서 선언한 식별자는 모듈 외부에서 참조할 수 없다.
모듈 스코프가 다르기 때문이다.

**48.3.2 export 키워드**

모듈 내부에서 선언한 식별자를 외부에 공개하여 다른 모듈들이 재사용할 수 있게 하려면 export 키워드를 사용한다.

**48.3.3 import 키워드**

다른 모듈에서 공개한 식별자를 자신의 모듈 스코프 내부로 로드하려면 import 키워드를 사용한다.
